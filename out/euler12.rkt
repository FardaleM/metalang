#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))

(define (max2 a b)
  ;toto
  (max a b)
)
(define (eratostene t_ max_)
  ;toto
  (let ([n 0])
  (let ([bg 2])
  (let ([bh (- max_ 1)])
  (letrec ([bd (lambda (i n) 
                 (if (<= i bh)
                 (let ([n (if (eq? (vector-ref t_ i) i)
                          (let ([j (* i i)])
                          (let ([n (+ n 1)])
                          (letrec ([bf (lambda (j) 
                                         (if (and (< j max_) (> j 0))
                                         (block
                                           (vector-set! t_ j 0)
                                           (let ([j (+ j i)])
                                           (bf j))
                                           )
                                         n))])
                          (bf j))))
                 n)])
                 (bd (+ i 1) n))
                 n))])
  (bd bg n)))))
)
(define (fillPrimesFactors t_ n primes nprimes)
  ;toto
  (let ([bb 0])
  (let ([bc (- nprimes 1)])
  (letrec ([y (lambda (i n) 
                (if (<= i bc)
                (let ([d (vector-ref primes i)])
                (letrec ([ba (lambda (n) 
                               (if (eq? (remainder n d) 0)
                               (block
                                 (vector-set! t_ d (+ (vector-ref t_ d) 1))
                                 (let ([n (quotient n d)])
                                 (ba n))
                                 )
                               (if (eq? n 1)
                               (vector-ref primes i)
                               (y (+ i 1) n))))])
                (ba n)))
                n))])
  (y bb n))))
)
(define (find_ ndiv2)
  ;toto
  (let ([maximumprimes 110])
  (let ([era (array_init_withenv maximumprimes (lambda (j) 
                                                 (lambda (_) (let ([e j])
                                                             (list '() e)))) '())])
  (let ([nprimes (eratostene era maximumprimes)])
  (let ([primes (array_init_withenv nprimes (lambda (o) 
                                              (lambda (_) (let ([f 0])
                                                          (list '() f)))) '())])
  (let ([l 0])
  (let ([w 2])
  (let ([x (- maximumprimes 1)])
  (letrec ([v (lambda (k l) 
                (if (<= k x)
                (let ([l (if (eq? (vector-ref era k) k)
                         (block
                           (vector-set! primes l k)
                           (let ([l (+ l 1)])
                           l)
                           )
                         l)])
                (v (+ k 1) l))
                (let ([s 1])
                (let ([u 10000])
                (letrec ([g (lambda (n) 
                              (if (<= n u)
                              (let ([primesFactors (array_init_withenv (+ n 2) 
                              (lambda (m) 
                                (lambda (_) (let ([h 0])
                                            (list '() h)))) '())])
                              (let ([max_ (max2 (fillPrimesFactors primesFactors n primes nprimes) (fillPrimesFactors primesFactors (+ n 1) primes nprimes))])
                              (block
                                (vector-set! primesFactors 2 (- (vector-ref primesFactors 2) 1))
                                (let ([ndivs 1])
                                (let ([q 0])
                                (let ([r max_])
                                (letrec ([p (lambda (i ndivs) 
                                              (if (<= i r)
                                              (let ([ndivs (if (not (eq? (vector-ref primesFactors i) 0))
                                                           (let ([ndivs (* ndivs (+ 1 (vector-ref primesFactors i)))])
                                                           ndivs)
                                                           ndivs)])
                                              (p (+ i 1) ndivs))
                                              (if (> ndivs ndiv2)
                                              (quotient (* n (+ n 1)) 2)
                                              ; print "n=" print n print "\t" print (n * (n + 1) / 2 ) print " " print ndivs print "\n" 
                                              (g (+ n 1)))))])
                                (p q ndivs)))))
                              )))
                  0))])
                (g s))))))])
  (v w l)))))))))
)
(define main
  (block
    (map display (list (find_ 500) "\n"))
    '()
    )
)

