#lang racket
(require racket/block)

(define (eratostene t0 max0)
  (let ([n 0])
  (letrec ([c (lambda (i n) 
                (if (<= i (- max0 1))
                (if (eq? (vector-ref t0 i) i)
                (let ([j (* i i)])
                (let ([n (+ n 1)])
                (letrec ([e (lambda (j) 
                              (if (and (< j max0) (> j 0))
                              (block
                                (vector-set! t0 j 0)
                                (let ([j (+ j i)])
                                (e j))
                                )
                              (c (+ i 1) n)))])
                (e j))))
                (c (+ i 1) n))
                n))])
  (c 2 n)))
)
(define (fillPrimesFactors t0 n primes nprimes)
  (letrec ([f (lambda (i n) 
                (if (<= i (- nprimes 1))
                (let ([d (vector-ref primes i)])
                (letrec ([g (lambda (n) 
                              (if (eq? (remainder n d) 0)
                              (block
                                (vector-set! t0 d (+ (vector-ref t0 d) 1))
                                (let ([n (quotient n d)])
                                (g n))
                                )
                              (if (eq? n 1)
                              (vector-ref primes i)
                              (f (+ i 1) n))))])
                (g n)))
                n))])
(f 0 n))
)
(define (find0 ndiv2)
  (let ([maximumprimes 110])
  (let ([era (build-vector maximumprimes (lambda (j) 
                                           j))])
  (let ([nprimes (eratostene era maximumprimes)])
  (let ([primes (build-vector nprimes (lambda (o) 
                                        0))])
  (let ([l 0])
  (letrec ([h (lambda (k l) 
                (if (<= k (- maximumprimes 1))
                (if (eq? (vector-ref era k) k)
                (block
                  (vector-set! primes l k)
                  (let ([l (+ l 1)])
                  (h (+ k 1) l))
                  )
                (h (+ k 1) l))
                (letrec ([p (lambda (n) 
                              (if (<= n 10000)
                              (let ([primesFactors (build-vector (+ n 2) (lambda (m) 
                                                                           0))])
                              (let ([max0 (max (fillPrimesFactors primesFactors n primes nprimes) (fillPrimesFactors primesFactors (+ n 1) primes nprimes))])
                              (block
                                (vector-set! primesFactors 2 (- (vector-ref primesFactors 2) 1))
                                (let ([ndivs 1])
                                (letrec ([q (lambda (i ndivs) 
                                              (if (<= i max0)
                                              (if (not (eq? (vector-ref primesFactors i) 0))
                                              (let ([ndivs (* ndivs (+ 1 (vector-ref primesFactors i)))])
                                              (q (+ i 1) ndivs))
                                              (q (+ i 1) ndivs))
                                              (if (> ndivs ndiv2)
                                              (quotient (* n (+ n 1)) 2)
                                              ; print "n=" print n print "\t" print (n * (n + 1) / 2 ) print " " print ndivs print "\n" 
                                              (p (+ n 1)))))])
                                (q 0 ndivs)))
                              )))
                  0))])
    (p 1))))])
  (h 2 l)))))))
)
(define main
  (printf "~a\n" (find0 500))
)

