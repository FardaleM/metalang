#lang racket
(require racket/block)

(define (eratostene t0 max0)
  ;toto
  (let ([n 0])
  (let ([ba (- max0 1)])
  (letrec ([y (lambda (i n) 
                (if (<= i ba)
                (if (eq? (vector-ref t0 i) i)
                (let ([j (* i i)])
                (let ([n (+ n 1)])
                (letrec ([z (lambda (j) 
                              (if (and (< j max0) (> j 0))
                              (block
                                (vector-set! t0 j 0)
                                (let ([j (+ j i)])
                                (z j))
                                )
                              (y (+ i 1) n)))])
                (z j))))
                (y (+ i 1) n))
                n))])
  (y 2 n))))
)
(define (fillPrimesFactors t0 n primes nprimes)
  ;toto
  (let ([x (- nprimes 1)])
  (letrec ([v (lambda (i n) 
                (if (<= i x)
                (let ([d (vector-ref primes i)])
                (letrec ([w (lambda (n) 
                              (if (eq? (remainder n d) 0)
                              (block
                                (vector-set! t0 d (+ (vector-ref t0 d) 1))
                                (let ([n (quotient n d)])
                                (w n))
                                )
                              (if (eq? n 1)
                              (vector-ref primes i)
                              (v (+ i 1) n))))])
                (w n)))
                n))])
  (v 0 n)))
)
(define (find0 ndiv2)
  ;toto
  (let ([maximumprimes 110])
  (let ([era (build-vector maximumprimes (lambda (j) 
                                           j))])
  (let ([nprimes (eratostene era maximumprimes)])
  (let ([primes (build-vector nprimes (lambda (o) 
                                        0))])
  (let ([l 0])
  (let ([u (- maximumprimes 1)])
  (letrec ([s (lambda (k l) 
                (if (<= k u)
                (if (eq? (vector-ref era k) k)
                (block
                  (vector-set! primes l k)
                  (let ([l (+ l 1)])
                  (s (+ k 1) l))
                  )
                (s (+ k 1) l))
                (letrec ([h (lambda (n) 
                              (if (<= n 10000)
                              (let ([primesFactors (build-vector (+ n 2) (lambda (m) 
                                                                           0))])
                              (let ([max0 (max (fillPrimesFactors primesFactors n primes nprimes) (fillPrimesFactors primesFactors (+ n 1) primes nprimes))])
                              (block
                                (vector-set! primesFactors 2 (- (vector-ref primesFactors 2) 1))
                                (let ([ndivs 1])
                                (letrec ([r (lambda (i ndivs) 
                                              (if (<= i max0)
                                              (if (not (eq? (vector-ref primesFactors i) 0))
                                              (let ([ndivs (* ndivs (+ 1 (vector-ref primesFactors i)))])
                                              (r (+ i 1) ndivs))
                                              (r (+ i 1) ndivs))
                                              (if (> ndivs ndiv2)
                                              (quotient (* n (+ n 1)) 2)
                                              ; print "n=" print n print "\t" print (n * (n + 1) / 2 ) print " " print ndivs print "\n" 
                                              (h (+ n 1)))))])
                                (r 0 ndivs)))
                              )))
                  0))])
    (h 1))))])
  (s 2 l))))))))
)
(define main
  (block
    (map display (list (find0 500) "\n"))
    '()
    )
)

