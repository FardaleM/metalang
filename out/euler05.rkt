#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))

(define (primesfactors n)
  ;toto
  (let ([tab (array_init_withenv (+ n 1) (lambda (i) 
                                           (lambda (_) (let ([p 0])
                                                       (list '() p)))) '())])
  (let ([d 2])
  (letrec ([q (lambda (d n) 
                (if (and (not (eq? n 1)) (<= (* d d) n))
                ((lambda (internal_env) (apply (lambda (d n) 
                                                      (q d n)) internal_env)) 
                (if (eq? (remainder n d) 0)
                (block
                  (vector-set! tab d (+ (vector-ref tab d) 1))
                  (let ([n (quotient n d)])
                  (list d n))
                  )
                (let ([d (+ d 1)])
                (list d n))))
                (block
                  (vector-set! tab n (+ (vector-ref tab n) 1))
                  tab
                  )))])
  (q d n))))
)
(define main
  (let ([lim 20])
  (let ([o (array_init_withenv (+ lim 1) (lambda (m) 
                                           (lambda (_) (let ([r 0])
                                                       (list '() r)))) '())])
  (let ([bd 1])
  (let ([be lim])
  (letrec ([z (lambda (i) 
                (if (<= i be)
                (let ([t0 (primesfactors i)])
                (let ([bb 1])
                (let ([bc i])
                (letrec ([ba (lambda (j) 
                               (if (<= j bc)
                               (block
                                 (vector-set! o j (max (vector-ref o j) (vector-ref t0 j)))
                                 (ba (+ j 1))
                                 )
                               (z (+ i 1))))])
                (ba bb)))))
                (let ([product 1])
                (let ([x 1])
                (let ([y lim])
                (letrec ([s (lambda (k product) 
                              (if (<= k y)
                              (let ([v 1])
                              (let ([w (vector-ref o k)])
                              (letrec ([u (lambda (l product) 
                                            (if (<= l w)
                                            (let ([product (* product k)])
                                            (u (+ l 1) product))
                                            (s (+ k 1) product)))])
                              (u v product))))
                              (block
                                (map display (list product "\n"))
                                )))])
                (s x product)))))))])
  (z bd))))))
)

