#lang racket
(require racket/block)

(define (primesfactors n)
  (let ([tab (build-vector (+ n 1) (lambda (i) 
                                     0))])
  (let ([d 2])
  (letrec ([c (lambda (d n) 
                (if (and (not (eq? n 1)) (<= (* d d) n))
                (if (eq? (remainder n d) 0)
                (block
                  (vector-set! tab d (+ (vector-ref tab d) 1))
                  (let ([n (quotient n d)])
                  (c d n))
                  )
                (let ([d (+ d 1)])
                (c d n)))
                (block
                  (vector-set! tab n (+ (vector-ref tab n) 1))
                  tab
                  )))])
  (c d n))))
)
(define main
  (let ([lim 20])
  (let ([o (build-vector (+ lim 1) (lambda (m) 
                                     0))])
  (letrec ([e (lambda (i) 
                (if (<= i lim)
                (let ([t0 (primesfactors i)])
                (letrec ([f (lambda (j) 
                              (if (<= j i)
                              (block
                                (vector-set! o j (max (vector-ref o j) (vector-ref t0 j)))
                                (f (+ j 1))
                                )
                              (e (+ i 1))))])
                (f 1)))
                (let ([product 1])
                (letrec ([g (lambda (k product) 
                              (if (<= k lim)
                              (let ([h (vector-ref o k)])
                              (letrec ([p (lambda (l product) 
                                            (if (<= l h)
                                            (let ([product (* product k)])
                                            (p (+ l 1) product))
                                            (g (+ k 1) product)))])
                              (p 1 product)))
                              (printf "~a\n" product)))])
                (g 1 product)))))])
(e 1))))
)

