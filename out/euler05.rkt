#lang racket
(require racket/block)

(define (primesfactors n)
  (let ([tab (build-vector (+ n 1) (lambda (i) 
                                     0))])
  (let ([d 2])
  (letrec ([c (lambda (d n) (if (and (not (eq? n 1)) (<= (* d d) n))
                            (if (eq? (remainder n d) 0)
                            (block
                              (vector-set! tab d (+ (vector-ref tab d) 1))
                              (let ([n (quotient n d)])
                              (c d n))
                              )
                            (let ([d (+ d 1)])
                            (c d n)))
                            (block
                              (vector-set! tab n (+ (vector-ref tab n) 1))
                              tab
                              )))])
    (c d n))))
)
(define main
  (let ([lim 20])
  (let ([o (build-vector (+ lim 1) (lambda (m) 
                                     0))])
  (letrec ([e (lambda (i) (if (<= i lim)
                          (let ([t0 (primesfactors i)])
                          (letrec ([p (lambda (j) (if (<= j i)
                                                  (block
                                                    (vector-set! o j (max (vector-ref o j) (vector-ref t0 j)))
                                                    (p (+ j 1))
                                                    )
                                                  (e (+ i 1))))])
                            (p 1)))
                          (let ([product 1])
                          (letrec ([f (lambda (k product) (if (<= k lim)
                                                          (let ([g (vector-ref o k)])
                                                          (letrec ([h (lambda (l product) 
                                                            (if (<= l g)
                                                            (let ([product (* product k)])
                                                            (h (+ l 1) product))
                                                            (f (+ k 1) product)))])
                                                            (h 1 product)))
                                                          (printf "~a\n" product)))])
                            (f 1 product)))))])
    (e 1))))
)

