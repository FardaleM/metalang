#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))

(define (primesfactors n)
  ;toto
  (let ([tab (array_init_withenv (+ n 1) (lambda (i) 
                                           (lambda (_) (let ([c 0])
                                                       (list '() c)))) '())])
  (let ([d 2])
  (letrec ([e (lambda (d n) 
                (if (and (not (eq? n 1)) (<= (* d d) n))
                ((lambda (internal_env) (apply (lambda (d n) 
                                                      (e d n)) internal_env)) 
                (if (eq? (remainder n d) 0)
                (block
                  (vector-set! tab d (+ (vector-ref tab d) 1))
                  (let ([n (quotient n d)])
                  (list d n))
                  )
                (let ([d (+ d 1)])
                (list d n))))
                (block
                  (vector-set! tab n (+ (vector-ref tab n) 1))
                  tab
                  )))])
  (e d n))))
)
(define main
  (let ([lim 20])
  (let ([o (array_init_withenv (+ lim 1) (lambda (m) 
                                           (lambda (_) (let ([f 0])
                                                       (list '() f)))) '())])
  (let ([y 1])
  (let ([z lim])
  (letrec ([u (lambda (i) 
                (if (<= i z)
                (let ([t0 (primesfactors i)])
                (let ([w 1])
                (let ([x i])
                (letrec ([v (lambda (j) 
                              (if (<= j x)
                              (block
                                (vector-set! o j (max (vector-ref o j) (vector-ref t0 j)))
                                (v (+ j 1))
                                )
                              (u (+ i 1))))])
                (v w)))))
                (let ([product 1])
                (let ([r 1])
                (let ([s lim])
                (letrec ([g (lambda (k product) 
                              (if (<= k s)
                              (let ([p 1])
                              (let ([q (vector-ref o k)])
                              (letrec ([h (lambda (l product) 
                                            (if (<= l q)
                                            (let ([product (* product k)])
                                            (h (+ l 1) product))
                                            (g (+ k 1) product)))])
                              (h p product))))
                              (block
                                (map display (list product "\n"))
                                )))])
                (g r product)))))))])
  (u y))))))
)

