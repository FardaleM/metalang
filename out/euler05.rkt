#lang racket
(require racket/block)

(define (primesfactors n)
  ;toto
  (let ([tab (build-vector (+ n 1) (lambda (i) 
                                     0))])
  (let ([d 2])
  (letrec ([f (lambda (d n) 
                (if (and (not (eq? n 1)) (<= (* d d) n))
                (if (eq? (remainder n d) 0)
                (block
                  (vector-set! tab d (+ (vector-ref tab d) 1))
                  (let ([n (quotient n d)])
                  (f d n))
                  )
                (let ([d (+ d 1)])
                (f d n)))
                (block
                  (vector-set! tab n (+ (vector-ref tab n) 1))
                  tab
                  )))])
  (f d n))))
)
(define main
  (let ([lim 20])
  (let ([o (build-vector (+ lim 1) (lambda (m) 
                                     0))])
  (letrec ([s (lambda (i) 
                (if (<= i lim)
                (let ([t0 (primesfactors i)])
                (letrec ([u (lambda (j) 
                              (if (<= j i)
                              (block
                                (vector-set! o j (max (vector-ref o j) (vector-ref t0 j)))
                                (u (+ j 1))
                                )
                              (s (+ i 1))))])
                (u 1)))
                (let ([product 1])
                (letrec ([p (lambda (k product) 
                              (if (<= k lim)
                              (let ([r (vector-ref o k)])
                              (letrec ([q (lambda (l product) 
                                            (if (<= l r)
                                            (let ([product (* product k)])
                                            (q (+ l 1) product))
                                            (p (+ k 1) product)))])
                              (q 1 product)))
                              (printf "~a\n" product)))])
                (p 1 product)))))])
(s 1))))
)

