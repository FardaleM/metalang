#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))

(define (max2 a b)
  ;toto
  (max a b)
)
(define (primesfactors n)
  ;toto
  (let ([tab (array_init_withenv (+ n 1) (lambda (i) 
                                           (lambda (_) (let ([f 0])
                                                       (list '() f)))) '())])
  (let ([d 2])
  (letrec ([h (lambda (d n) 
                (if (and (not (eq? n 1)) (<= (* d d) n))
                ((lambda (internal_env) (apply (lambda (d n) 
                                                      (h d n)) internal_env)) 
                (if (eq? (remainder n d) 0)
                (block
                  (vector-set! tab d (+ (vector-ref tab d) 1))
                  (let ([n (quotient n d)])
                  (list d n))
                  )
                (let ([d (+ d 1)])
                (list d n))))
                (block
                  (vector-set! tab n (+ (vector-ref tab n) 1))
                  tab
                  )))])
  (h d n))))
)
(define main
  (let ([lim 20])
  (let ([o (array_init_withenv (+ lim 1) (lambda (m) 
                                           (lambda (_) (let ([p 0])
                                                       (list '() p)))) '())])
  (let ([bb 1])
  (let ([bc lim])
  (letrec ([x (lambda (i) 
                (if (<= i bc)
                (let ([t_ (primesfactors i)])
                (let ([z 1])
                (let ([ba i])
                (letrec ([y (lambda (j) 
                              (if (<= j ba)
                              (block
                                (vector-set! o j (max2 (vector-ref o j) (vector-ref t_ j)))
                                (y (+ j 1))
                                )
                              (x (+ i 1))))])
                (y z)))))
                (let ([product 1])
                (let ([v 1])
                (let ([w lim])
                (letrec ([q (lambda (k product) 
                              (if (<= k w)
                              (let ([s 1])
                              (let ([u (vector-ref o k)])
                              (letrec ([r (lambda (l product) 
                                            (if (<= l u)
                                            (let ([product (* product k)])
                                            (r (+ l 1) product))
                                            (q (+ k 1) product)))])
                              (r s product))))
                              (block
                                (map display (list product "\n"))
                                )))])
                (q v product)))))))])
  (x bb))))))
)

