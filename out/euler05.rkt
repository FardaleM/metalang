#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))

(define (primesfactors n)
  ;toto
  (let ([tab (array_init_withenv (+ n 1) (lambda (i) 
                                           (lambda (_) (let ([p 0])
                                                       (list '() p)))) '())])
  (let ([d 2])
  (letrec ([r (lambda (d n) 
                (if (and (not (eq? n 1)) (<= (* d d) n))
                ((lambda (internal_env) (apply (lambda (d n) 
                                                      (r d n)) internal_env)) 
                (if (eq? (remainder n d) 0)
                (block
                  (vector-set! tab d (+ (vector-ref tab d) 1))
                  (let ([n (quotient n d)])
                  (list d n))
                  )
                (let ([d (+ d 1)])
                (list d n))))
                (block
                  (vector-set! tab n (+ (vector-ref tab n) 1))
                  tab
                  )))])
  (r d n))))
)
(define main
  (let ([lim 20])
  (let ([o (array_init_withenv (+ lim 1) (lambda (m) 
                                           (lambda (_) (let ([s 0])
                                                       (list '() s)))) '())])
  (let ([be 1])
  (let ([bf lim])
  (letrec ([ba (lambda (i) 
                 (if (<= i bf)
                 (let ([t_ (primesfactors i)])
                 (let ([bc 1])
                 (let ([bd i])
                 (letrec ([bb (lambda (j) 
                                (if (<= j bd)
                                (let ([g (vector-ref o j)])
                                (let ([h (vector-ref t_ j)])
                                (let ([f (max g h)])
                                (block
                                  (vector-set! o j f)
                                  (bb (+ j 1))
                                  ))))
                                (ba (+ i 1))))])
                 (bb bc)))))
                 (let ([product 1])
                 (let ([y 1])
                 (let ([z lim])
                 (letrec ([u (lambda (k product) 
                               (if (<= k z)
                               (let ([w 1])
                               (let ([x (vector-ref o k)])
                               (letrec ([v (lambda (l product) 
                                             (if (<= l x)
                                             (let ([product (* product k)])
                                             (v (+ l 1) product))
                                             (u (+ k 1) product)))])
                               (v w product))))
                               (block
                                 (map display (list product "\n"))
                                 )))])
                 (u y product)))))))])
  (ba be))))))
)

