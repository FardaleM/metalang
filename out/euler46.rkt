#lang racket
(require racket/block)

(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))
(define last-char 0)
(define next-char (lambda () (set! last-char (read-char (current-input-port)))))
(next-char)
(define mread-char (lambda ()
  (let ([ out last-char])
    (block
      (next-char)
      out
    ))))

(define mread-int (lambda ()
  (if (eq? #\- last-char)
  (block
    (next-char) (- 0 (mread-int)))
    (letrec ([w (lambda (out)
      (if (eof-object? last-char)
        out
        (if (and last-char (>= (char->integer last-char) (char->integer #\0)) (<= (char->integer last-char) (char->integer #\9)))
          (let ([out (+ (* 10 out) (- (char->integer last-char) (char->integer #\0)))])
            (block
              (next-char)
              (w out)
          ))
        out
      )))]) (w 0)))))

(define mread-blank (lambda ()
  (if (or (eq? last-char #\NewLine) (eq? last-char #\Space) ) (block (next-char) (mread-blank)) '())
))

(define eratostene (lambda (t_ max_) 
                     (let ([n 0])
                       (let ([f 2])
                         (let ([g (- max_ 1)])
                           (letrec ([a (lambda (i n t_ max_) 
                                         (if (<= i g)
                                           (let ([b (lambda (n t_ max_) 
                                                      (a (+ i 1) n t_ max_))])
                                           (if (eq? (vector-ref t_ i) i)
                                             (let ([n (+ n 1)])
                                               (let ([j (* i i)])
                                                 (let ([c (lambda (j n t_ max_) 
                                                            (b n t_ max_))])
                                                 (if (eq? (quotient j i) i)
                                                   ; overflow test 
                                                   (letrec ([e (lambda (j n t_ max_) 
                                                                 (if (and (< j max_) (> j 0))
                                                                   (block
                                                                    (vector-set! t_ j 0)
                                                                    (let ([j (+ j i)])
                                                                    (e j n t_ max_))
                                                                    )
                                                                   (c j n t_ max_)))])
                                                   (e j n t_ max_))
                                                 (c j n t_ max_)))))
                                         (b n t_ max_)))
                           n))])
                     (a f n t_ max_)))))))
(define main (let ([maximumprimes 6000])
               (let ([era (array_init_withenv maximumprimes (lambda (j_) 
                                                              (lambda (maximumprimes) 
                                                                (let ([h j_])
                                                                  (list maximumprimes h)))) maximumprimes)])
  (let ([nprimes (eratostene era maximumprimes)])
    (let ([primes (array_init_withenv nprimes (lambda (o) 
                                                (lambda (internal_env) (apply (lambda
                                                 (nprimes maximumprimes) 
                                                (let ([p 0])
                                                  (list (list nprimes maximumprimes) p))) internal_env))) (list nprimes maximumprimes))])
    (let ([l 0])
      (let ([bf 2])
        (let ([bg (- maximumprimes 1)])
          (letrec ([bd (lambda (k l nprimes maximumprimes) 
                         (if (<= k bg)
                           (let ([be (lambda (l nprimes maximumprimes) 
                                       (bd (+ k 1) l nprimes maximumprimes))])
                           (if (eq? (vector-ref era k) k)
                             (block
                               (vector-set! primes l k)
                               (let ([l (+ l 1)])
                                 (be l nprimes maximumprimes))
                               )
                             (be l nprimes maximumprimes)))
                         (block
                           (display l)
                           (display " == ")
                           (display nprimes)
                           (display "\n")
                           (let ([canbe (array_init_withenv maximumprimes 
                             (lambda (i_) 
                               (lambda (internal_env) (apply (lambda (l nprimes maximumprimes) 
                                                                    (let ([q #f])
                                                                    (list (list l nprimes maximumprimes) q))) internal_env))) (list l nprimes maximumprimes))])
                           (let ([bb 0])
                             (let ([bc (- nprimes 1)])
                               (letrec ([w (lambda (i l nprimes maximumprimes) 
                                             (if (<= i bc)
                                               (let ([z 0])
                                                 (let ([ba (- maximumprimes 1)])
                                                   (letrec ([x (lambda (j l nprimes maximumprimes) 
                                                                 (if (<= j ba)
                                                                   (let ([n (+ (vector-ref primes i) (* (* 2 j) j))])
                                                                    (let ([y 
                                                                    (lambda (n l nprimes maximumprimes) 
                                                                    (x (+ j 1) l nprimes maximumprimes))])
                                                                    (if (< n maximumprimes)
                                                                    (block
                                                                    (vector-set! canbe n #t)
                                                                    (y n l nprimes maximumprimes)
                                                                    )
                                                                    (y n l nprimes maximumprimes))))
                                                                 (w (+ i 1) l nprimes maximumprimes)))])
                                                 (x z l nprimes maximumprimes))))
                                 (let ([u 1])
                                   (let ([v maximumprimes])
                                     (letrec ([r (lambda (m l nprimes maximumprimes) 
                                                   (if (<= m v)
                                                     (let ([m2 (+ (* m 2) 1)])
                                                       (let ([s (lambda (m2 l nprimes maximumprimes) 
                                                                  (r (+ m 1) l nprimes maximumprimes))])
                                                       (if (and (< m2 maximumprimes) (not (vector-ref canbe m2)))
                                                         (block
                                                           (display m2)
                                                           (display "\n")
                                                           (s m2 l nprimes maximumprimes)
                                                           )
                                                         (s m2 l nprimes maximumprimes))))
                                                   '()))])
                                   (r u l nprimes maximumprimes))))))])
            (w bb l nprimes maximumprimes)))))
    )))])
(bd bf l nprimes maximumprimes))))))))))

