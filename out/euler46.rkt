#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))

(define (eratostene t_ max_)
  ;toto
  (let ([n 0])
  (let ([d 2])
  (let ([e (- max_ 1)])
  (letrec ([a (lambda (i n) 
                (if (<= i e)
                (let ([n (if (eq? (vector-ref t_ i) i)
                         (let ([n (+ n 1)])
                         (let ([j (* i i)])
                         (let ([j (if (eq? (quotient j i) i)
                                  ; overflow test 
                                  (letrec ([c (lambda (j) 
                                                (if (and (< j max_) (> j 0))
                                                (block
                                                  (vector-set! t_ j 0)
                                                  (let ([j (+ j i)])
                                                  (c j))
                                                  )
                                                j))])
                                  (c j))
                         j)])
                         n)))
                n)])
                (a (+ i 1) n))
                n))])
  (a d n)))))
)
(define main
  (let ([maximumprimes 6000])
  (let ([era (array_init_withenv maximumprimes (lambda (j_) 
                                                 (lambda (_) (let ([f j_])
                                                             (list '() f)))) '())])
  (let ([nprimes (eratostene era maximumprimes)])
  (let ([primes (array_init_withenv nprimes (lambda (o) 
                                              (lambda (_) (let ([g 0])
                                                          (list '() g)))) '())])
  (let ([l 0])
  (let ([ba 2])
  (let ([bb (- maximumprimes 1)])
  (letrec ([z (lambda (k l) 
                (if (<= k bb)
                (let ([l (if (eq? (vector-ref era k) k)
                         (block
                           (vector-set! primes l k)
                           (let ([l (+ l 1)])
                           l)
                           )
                         l)])
                (z (+ k 1) l))
                (block
                  (map display (list l " == " nprimes "\n"))
                  (let ([canbe (array_init_withenv maximumprimes (lambda (i_) 
                                                                   (lambda (_) 
                                                                   (let ([h #f])
                                                                   (list '() h)))) '())])
                  (let ([x 0])
                  (let ([y (- nprimes 1)])
                  (letrec ([s (lambda (i) 
                                (if (<= i y)
                                (let ([v 0])
                                (let ([w (- maximumprimes 1)])
                                (letrec ([u (lambda (j) 
                                              (if (<= j w)
                                              (let ([n (+ (vector-ref primes i) (* (* 2 j) j))])
                                              (block
                                                (if (< n maximumprimes)
                                                (vector-set! canbe n #t)
                                                '())
                                                (u (+ j 1))
                                                ))
                                              (s (+ i 1))))])
                                (u v))))
                                (let ([q 1])
                                (let ([r maximumprimes])
                                (letrec ([p (lambda (m) 
                                              (if (<= m r)
                                              (let ([m2 (+ (* m 2) 1)])
                                              (block
                                                (if (and (< m2 maximumprimes) (not (vector-ref canbe m2)))
                                                (block
                                                  (map display (list m2 "\n"))
                                                  )
                                                '())
                                                (p (+ m 1))
                                                ))
                                              '()))])
                                (p q))))))])
                  (s x)))))
  )))])
  (z ba l)))))))))
)

