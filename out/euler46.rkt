#lang racket
(require racket/block)

(define (eratostene t0 max0)
  (let ([n 0])
  (letrec ([a (lambda (i n) 
                (if (<= i (- max0 1))
                (if (eq? (vector-ref t0 i) i)
                (let ([n (+ n 1)])
                (if (> (quotient max0 i) i)
                (let ([j (* i i)])
                (letrec ([b (lambda (j) 
                              (if (and (< j max0) (> j 0))
                              (block
                                (vector-set! t0 j 0)
                                (let ([j (+ j i)])
                                (b j))
                                )
                              (a (+ i 1) n)))])
                (b j)))
                (a (+ i 1) n)))
                (a (+ i 1) n))
                n))])
  (a 2 n)))
)
(define main
  (let ([maximumprimes 6000])
  (let ([era (build-vector maximumprimes (lambda (j_) 
                                           j_))])
  (let ([nprimes (eratostene era maximumprimes)])
  (let ([primes (build-vector nprimes (lambda (o) 
                                        0))])
  (let ([l 0])
  (letrec ([c (lambda (k l) 
                (if (<= k (- maximumprimes 1))
                (if (eq? (vector-ref era k) k)
                (block
                  (vector-set! primes l k)
                  (let ([l (+ l 1)])
                  (c (+ k 1) l))
                  )
                (c (+ k 1) l))
                (block
                  (printf "~a == ~a\n" l nprimes)
                  (let ([canbe (build-vector maximumprimes (lambda (i_) 
                                                             #f))])
                  (letrec ([d (lambda (i) 
                                (if (<= i (- nprimes 1))
                                (letrec ([f (lambda (j) 
                                              (if (<= j (- maximumprimes 1))
                                              (let ([n (+ (vector-ref primes i) (* 2 j j))])
                                              (if (< n maximumprimes)
                                              (block
                                                (vector-set! canbe n #t)
                                                (f (+ j 1))
                                                )
                                              (f (+ j 1))))
                                              (d (+ i 1))))])
                                (f 0))
                                (letrec ([e (lambda (m) 
                                              (if (<= m maximumprimes)
                                              (let ([m2 (+ (* m 2) 1)])
                                              (if (and (< m2 maximumprimes) (not (vector-ref canbe m2)))
                                              (block
                                                (printf "~a\n" m2)
                                                (e (+ m 1))
                                                )
                                              (e (+ m 1))))
                                              '()))])
                                (e 1))))])
                (d 0)))
  )))])
(c 2 l)))))))
)

