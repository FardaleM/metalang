#lang racket
(require racket/block)

(define (eratostene t0 max0)
  (let ([n 0])
  (letrec ([a (lambda (i n) 
                (if (<= i (- max0 1))
                (if (eq? (vector-ref t0 i) i)
                (let ([n (+ n 1)])
                (if (> (quotient max0 i) i)
                (let ([j (* i i)])
                (letrec ([b (lambda (j) 
                              (if (and (< j max0) (> j 0))
                              (block
                                (vector-set! t0 j 0)
                                (let ([j (+ j i)])
                                (b j))
                                )
                              (a (+ i 1) n)))])
                (b j)))
                (a (+ i 1) n)))
                (a (+ i 1) n))
                n))])
  (a 2 n)))
)
(define main
  (let ([maximumprimes 6000])
  (let ([era (build-vector maximumprimes (lambda (j_) 
                                           j_))])
  (let ([nprimes (eratostene era maximumprimes)])
  (let ([primes (build-vector nprimes (lambda (o) 
                                        0))])
  (let ([l 0])
  (letrec ([s (lambda (k l) 
                (if (<= k (- maximumprimes 1))
                (if (eq? (vector-ref era k) k)
                (block
                  (vector-set! primes l k)
                  (let ([l (+ l 1)])
                  (s (+ k 1) l))
                  )
                (s (+ k 1) l))
                (block
                  (printf "~a == ~a\n" l nprimes)
                  (let ([canbe (build-vector maximumprimes (lambda (i_) 
                                                             #f))])
                  (letrec ([q (lambda (i) 
                                (if (<= i (- nprimes 1))
                                (letrec ([r (lambda (j) 
                                              (if (<= j (- maximumprimes 1))
                                              (let ([n (+ (vector-ref primes i) (* 2 j j))])
                                              (if (< n maximumprimes)
                                              (block
                                                (vector-set! canbe n #t)
                                                (r (+ j 1))
                                                )
                                              (r (+ j 1))))
                                              (q (+ i 1))))])
                                (r 0))
                                (letrec ([p (lambda (m) 
                                              (if (<= m maximumprimes)
                                              (let ([m2 (+ (* m 2) 1)])
                                              (if (and (< m2 maximumprimes) (not (vector-ref canbe m2)))
                                              (block
                                                (printf "~a\n" m2)
                                                (p (+ m 1))
                                                )
                                              (p (+ m 1))))
                                              '()))])
                                (p 1))))])
                (q 0)))
  )))])
(s 2 l)))))))
)

