#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))

(define eratostene (lambda (t_ max_) 
                     (let ([n 0])
                       (let ([bf 2])
                         (let ([bg (- max_ 1)])
                           (letrec ([bc (lambda (i n) 
                                          (if (<= i bg)
                                            (let ([n (if (eq? (vector-ref t_ i) i)
                                                       (let ([n (+ n 1)])
                                                         (let ([j (* i i)])
                                                           (letrec ([be 
                                                             (lambda (j) 
                                                               (if (and (< j max_) (> j 0))
                                                                 (block
                                                                   (vector-set! t_ j 0)
                                                                   (let ([j (+ j i)])
                                                                    (be j))
                                                                   )
                                                                 n))])
                                                           (be j))))
                                              n)])
                                            (bc (+ i 1) n))
                                          n))])
                         (bc bf n)))))))
(define fillPrimesFactors (lambda (t_ n primes nprimes) 
                            (let ([ba 0])
                              (let ([bb (- nprimes 1)])
                                (letrec ([x (lambda (i n) 
                                              (if (<= i bb)
                                                (let ([d (vector-ref primes i)])
                                                  (letrec ([z (lambda (n) 
                                                                (if (eq? (remainder n d) 0)
                                                                  (block
                                                                    (vector-set! t_ d (+ (vector-ref t_ d) 1))
                                                                    (let ([n (quotient n d)])
                                                                    (z n))
                                                                    )
                                                                  (if (eq? n 1)
                                                                    (vector-ref primes i)
                                                                    (x (+ i 1) n))))])
                                                  (z n)))
                                              n))])
                              (x ba n))))))
(define sumdivaux2 (lambda (t_ n i) 
                     (letrec ([w (lambda (i) 
                                   (if (and (< i n) (eq? (vector-ref t_ i) 0))
                                     (let ([i (+ i 1)])
                                       (w i))
                                     i))])
                     (w i))))
(define sumdivaux (lambda (t_ n i) 
                    (let ([f (lambda (_) 
                               '())])
                    (if (> i n)
                      1
                      (let ([g (lambda (_) 
                                 (f 'nil))])
                      (if (eq? (vector-ref t_ i) 0)
                        (sumdivaux t_ n (sumdivaux2 t_ n (+ i 1)))
                        (let ([o (sumdivaux t_ n (sumdivaux2 t_ n (+ i 1)))])
                          (let ([out_ 0])
                            (let ([p i])
                              (let ([m 1])
                                (let ([u (vector-ref t_ i)])
                                  (letrec ([h (lambda (j out_ p) 
                                                (if (<= j u)
                                                  (let ([out_ (+ out_ p)])
                                                    (let ([p (* p i)])
                                                      (h (+ j 1) out_ p)))
                                                  (* (+ out_ 1) o)))])
                                  (h m out_ p)))))))))))))
(define sumdiv (lambda (nprimes primes n) 
                 (let ([a (+ n 1)])
                   (let ([t_ (array_init_withenv a (lambda (i) 
                                                     (lambda (_) (let ([e 0])
                                                                   (list '() e)))) '())])
                   (let ([max_ (fillPrimesFactors t_ n primes nprimes)])
                     (sumdivaux t_ max_ 0))))))
(define main (let ([maximumprimes 30001])
               (let ([era (array_init_withenv maximumprimes (lambda (s) 
                                                              (lambda (_) 
                                                              (let ([bh s])
                                                                (list '() bh)))) '())])
               (let ([nprimes (eratostene era maximumprimes)])
                 (let ([primes (array_init_withenv nprimes (lambda (t_) 
                                                             (lambda (_) 
                                                             (let ([bi 0])
                                                               (list '() bi)))) '())])
                 (let ([l 0])
                   (let ([by 2])
                     (let ([bz (- maximumprimes 1)])
                       (letrec ([bx (lambda (k l) 
                                      (if (<= k bz)
                                        (let ([l (if (eq? (vector-ref era k) k)
                                                   (block
                                                     (vector-set! primes l k)
                                                     (let ([l (+ l 1)])
                                                       l)
                                                     )
                                                   l)])
                                          (bx (+ k 1) l))
                                        (let ([n 100])
                                          ; 28124 Ã§a prend trop de temps mais on arrive a passer le test 
                                          (let ([b (+ n 1)])
                                            (let ([abondant (array_init_withenv b 
                                              (lambda (p) 
                                                (lambda (_) (let ([bj #f])
                                                              (list '() bj)))) '())])
                                            (let ([c (+ n 1)])
                                              (let ([summable (array_init_withenv c 
                                                (lambda (q) 
                                                  (lambda (_) (let ([bk #f])
                                                                (list '() bk)))) '())])
                                              (let ([sum 0])
                                                (let ([bv 2])
                                                  (let ([bw n])
                                                    (letrec ([bu (lambda (r) 
                                                                   (if (<= r bw)
                                                                    (let ([other (- (sumdiv nprimes primes r) r)])
                                                                    (block
                                                                    (if (> other r)
                                                                    (block
                                                                    (vector-set! abondant r #t)
                                                                    '()
                                                                    )
                                                                    '())
                                                                    (bu (+ r 1))
                                                                    ))
                                                                    (let ([bs 1])
                                                                    (let ([bt n])
                                                                    (letrec ([bo 
                                                                    (lambda (i) 
                                                                    (if (<= i bt)
                                                                    (let ([bq 1])
                                                                    (let ([br n])
                                                                    (letrec ([bp 
                                                                    (lambda (j) 
                                                                    (if (<= j br)
                                                                    (block
                                                                    (if (and (and (vector-ref abondant i) (vector-ref abondant j)) (<= (+ i j) n))
                                                                    (block
                                                                    (vector-set! summable (+ i j) #t)
                                                                    '()
                                                                    )
                                                                    '())
                                                                    (bp (+ j 1))
                                                                    )
                                                                    (bo (+ i 1))))])
                                                                    (bp bq))))
                                                                    (let ([bm 1])
                                                                    (let ([bn n])
                                                                    (letrec ([bl 
                                                                    (lambda (o sum) 
                                                                    (if (<= o bn)
                                                                    (let ([sum 
                                                                    (if (not (vector-ref summable o))
                                                                    (let ([sum (+ sum o)])
                                                                    sum)
                                                                    sum)])
                                                                    (bl (+ o 1) sum))
                                                                    (block
                                                                    (display "\n")
                                                                    (display sum)
                                                                    (display "\n")
                                                                    )))])
                                                                    (bl bm sum))))))])
                                                                    (bo bs))))))])
                                              (bu bv))))))))))))])
(bx by l))))))))))

