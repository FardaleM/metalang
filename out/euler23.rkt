#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (let ((tab (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    ))))) (list env tab))))

(define (eratostene t0 max0)
  ;toto
  (let ([n 0])
  (let ([ba 2])
  (let ([bb (- max0 1)])
  (letrec ([y (lambda (i n) 
                (if (<= i bb)
                (let ([n (if (eq? (vector-ref t0 i) i)
                         (let ([n (+ n 1)])
                         (let ([j (* i i)])
                         (letrec ([z (lambda (j) 
                                       (if (and (< j max0) (> j 0))
                                       (block
                                         (vector-set! t0 j 0)
                                         (let ([j (+ j i)])
                                         (z j))
                                         )
                                       n))])
                         (z j))))
                n)])
                (y (+ i 1) n))
                n))])
  (y ba n)))))
)
(define (fillPrimesFactors t0 n primes nprimes)
  ;toto
  (let ([w 0])
  (let ([x (- nprimes 1)])
  (letrec ([u (lambda (i n) 
                (if (<= i x)
                (let ([d (vector-ref primes i)])
                (letrec ([v (lambda (n) 
                              (if (eq? (remainder n d) 0)
                              (block
                                (vector-set! t0 d (+ (vector-ref t0 d) 1))
                                (let ([n (quotient n d)])
                                (v n))
                                )
                              (if (eq? n 1)
                              (vector-ref primes i)
                              (u (+ i 1) n))))])
                (v n)))
                n))])
  (u w n))))
)
(define (sumdivaux2 t0 n i)
  ;toto
  (letrec ([m (lambda (i) 
                (if (and (< i n) (eq? (vector-ref t0 i) 0))
                (let ([i (+ i 1)])
                (m i))
                i))])
  (m i))
)
(define (sumdivaux t0 n i)
  ;toto
  (let ([c (lambda (_) 
             '())])
  (if (> i n)
  1
  (let ([e (lambda (_) 
             (c 'nil))])
  (if (eq? (vector-ref t0 i) 0)
  (sumdivaux t0 n (sumdivaux2 t0 n (+ i 1)))
  (let ([o (sumdivaux t0 n (sumdivaux2 t0 n (+ i 1)))])
  (let ([out0 0])
  (let ([p i])
  (let ([g 1])
  (let ([h (vector-ref t0 i)])
  (letrec ([f (lambda (j out0 p) 
                (if (<= j h)
                (let ([out0 (+ out0 p)])
                (let ([p (* p i)])
                (f (+ j 1) out0 p)))
                (* (+ out0 1) o)))])
  (f g out0 p)))))))))))
)
(define (sumdiv nprimes primes n)
  ;toto
  ((lambda (internal_env) (apply (lambda (b t0) 
                                        (block
                                          b
                                          (let ([max0 (fillPrimesFactors t0 n primes nprimes)])
                                          (sumdivaux t0 max0 0))
                                          )) internal_env)) (array_init_withenv (+ n 1) 
  (lambda (i) 
    (lambda (_) (let ([a 0])
                (list '() a)))) '()))
)
(define main
  (let ([maximumprimes 30001])
  ((lambda (internal_env) (apply (lambda (bd era) 
                                        (block
                                          bd
                                          (let ([nprimes (eratostene era maximumprimes)])
                                          ((lambda (internal_env) (apply (lambda
                                           (bf primes) 
                                          (block
                                            bf
                                            (let ([l 0])
                                            (let ([bx 2])
                                            (let ([by (- maximumprimes 1)])
                                            (letrec ([bw (lambda (k l) 
                                                           (if (<= k by)
                                                           (let ([l (if (eq? (vector-ref era k) k)
                                                                    (block
                                                                    (vector-set! primes l k)
                                                                    (let ([l (+ l 1)])
                                                                    l)
                                                                    )
                                                                    l)])
                                                           (bw (+ k 1) l))
                                                           (let ([n 100])
                                                           ; 28124 Ã§a prend trop de temps mais on arrive a passer le test 
                                                           ((lambda (internal_env) (apply (lambda
                                                            (bh abondant) 
                                                           (block
                                                             bh
                                                             ((lambda (internal_env) (apply (lambda
                                                              (bj summable) 
                                                             (block
                                                               bj
                                                               (let ([sum 0])
                                                               (let ([bu 2])
                                                               (let ([bv n])
                                                               (letrec ([bt 
                                                                 (lambda (r) 
                                                                   (if (<= r bv)
                                                                   (let ([other (- (sumdiv nprimes primes r) r)])
                                                                   (block
                                                                    (if (> other r)
                                                                    (vector-set! abondant r #t)
                                                                    '())
                                                                    (bt (+ r 1))
                                                                    ))
                                                                   (let ([br 1])
                                                                   (let ([bs n])
                                                                   (letrec ([bn 
                                                                    (lambda (i) 
                                                                    (if (<= i bs)
                                                                    (let ([bp 1])
                                                                    (let ([bq n])
                                                                    (letrec ([bo 
                                                                    (lambda (j) 
                                                                    (if (<= j bq)
                                                                    (block
                                                                    (if (and (and (vector-ref abondant i) (vector-ref abondant j)) (<= (+ i j) n))
                                                                    (vector-set! summable (+ i j) #t)
                                                                    '())
                                                                    (bo (+ j 1))
                                                                    )
                                                                    (bn (+ i 1))))])
                                                                    (bo bp))))
                                                                    (let ([bl 1])
                                                                    (let ([bm n])
                                                                    (letrec ([bk 
                                                                    (lambda (o sum) 
                                                                    (if (<= o bm)
                                                                    (let ([sum 
                                                                    (if (not (vector-ref summable o))
                                                                    (let ([sum (+ sum o)])
                                                                    sum)
                                                                    sum)])
                                                                    (bk (+ o 1) sum))
                                                                    (block
                                                                    (map display (list "\n" sum "\n"))
                                                                    )))])
                                                                    (bk bl sum))))))])
                                                                   (bn br))))))])
                                                               (bt bu)))))
                                                           )) internal_env)) (array_init_withenv (+ n 1) 
                                                           (lambda (q) 
                                                             (lambda (_) 
                                                             (let ([bi #f])
                                                             (list '() bi)))) '()))
                                              )) internal_env)) (array_init_withenv (+ n 1) 
                                            (lambda (p) 
                                              (lambda (_) (let ([bg #f])
                                                          (list '() bg)))) '())))))])
                                          (bw bx l)))))
)) internal_env)) (array_init_withenv nprimes (lambda (t0) 
                                                (lambda (_) (let ([be 0])
                                                            (list '() be)))) '())))
)) internal_env)) (array_init_withenv maximumprimes (lambda (s) 
                                                      (lambda (_) (let ([bc s])
                                                                  (list '() bc)))) '())))
)

