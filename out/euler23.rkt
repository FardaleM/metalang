#lang racket
(require racket/block)

(define (eratostene t0 max0)
  (let ([n 0])
  (letrec ([a (lambda (i n) (if (<= i (- max0 1))
                            (if (eq? (vector-ref t0 i) i)
                            (let ([n (+ n 1)])
                            (let ([j (* i i)])
                            (letrec ([b (lambda (j) (if (and (< j max0) (> j 0))
                                                    (block
                                                      (vector-set! t0 j 0)
                                                      (let ([j (+ j i)])
                                                      (b j))
                                                      )
                                                    (a (+ i 1) n)))])
                              (b j))))
                            (a (+ i 1) n))
                            n))])
    (a 2 n)))
)

(define (fillPrimesFactors t0 n primes nprimes)
  (letrec ([c (lambda (i n) (if (<= i (- nprimes 1))
                            (let ([d (vector-ref primes i)])
                            (letrec ([e (lambda (n) (if (eq? (remainder n d) 0)
                                                    (block
                                                      (vector-set! t0 d (+ (vector-ref t0 d) 1))
                                                      (let ([n (quotient n d)])
                                                      (e n))
                                                      )
                                                    (if (eq? n 1)
                                                    (vector-ref primes i)
                                                    (c (+ i 1) n))))])
                              (e n)))
                            n))])
    (c 0 n))
)

(define (sumdivaux2 t0 n i)
  (letrec ([f (lambda (i) (if (and (< i n) (eq? (vector-ref t0 i) 0))
                          (let ([i (+ i 1)])
                          (f i))
                          i))])
    (f i))
)

(define (sumdivaux t0 n i)
  (if (> i n)
  1
  (if (eq? (vector-ref t0 i) 0)
  (sumdivaux t0 n (sumdivaux2 t0 n (+ i 1)))
  (let ([o (sumdivaux t0 n (sumdivaux2 t0 n (+ i 1)))])
  (let ([out0 0])
  (let ([p i])
  (let ([g (vector-ref t0 i)])
  (letrec ([h (lambda (j out0 p) (if (<= j g)
                                 (let ([out0 (+ out0 p)])
                                 (let ([p (* p i)])
                                 (h (+ j 1) out0 p)))
                                 (* (+ out0 1) o)))])
    (h 1 out0 p))))))))
)

(define (sumdiv nprimes primes n)
  (let ([t0 (build-vector (+ n 1) (lambda (i) 
                                    0))])
  (let ([max0 (fillPrimesFactors t0 n primes nprimes)])
  (sumdivaux t0 max0 0)))
)

(define main
  (let ([maximumprimes 30001])
  (let ([era (build-vector maximumprimes (lambda (s) 
                                           s))])
  (let ([nprimes (eratostene era maximumprimes)])
  (let ([primes (build-vector nprimes (lambda (t0) 
                                        0))])
  (let ([l 0])
  (letrec ([m (lambda (k l) (if (<= k (- maximumprimes 1))
                            (if (eq? (vector-ref era k) k)
                            (block
                              (vector-set! primes l k)
                              (let ([l (+ l 1)])
                              (m (+ k 1) l))
                              )
                            (m (+ k 1) l))
                            (let ([n 100])
                            ; 28124 Ã§a prend trop de temps mais on arrive a passer le test 
                            (let ([abondant (build-vector (+ n 1) (lambda (p) 
                                                                    #f))])
                            (let ([summable (build-vector (+ n 1) (lambda (q) 
                                                                    #f))])
                            (let ([sum 0])
                            (letrec ([u (lambda (r) (if (<= r n)
                                                    (let ([other (- (sumdiv nprimes primes r) r)])
                                                    (if (> other r)
                                                    (block
                                                      (vector-set! abondant r #t)
                                                      (u (+ r 1))
                                                      )
                                                    (u (+ r 1))))
                                                    (letrec ([v (lambda (i) (if (<= i n)
                                                                            (letrec ([x (lambda (j) 
                                                                              (if (<= j n)
                                                                              (if (and (vector-ref abondant i) (vector-ref abondant j) (<= (+ i j) n))
                                                                              (block
                                                                                (vector-set! summable (+ i j) #t)
                                                                                (x (+ j 1))
                                                                                )
                                                                              (x (+ j 1)))
                                                                              (v (+ i 1))))])
                                                                              (x 1))
                                                                            (letrec ([w (lambda (o sum) 
                                                                              (if (<= o n)
                                                                              (if (not (vector-ref summable o))
                                                                              (let ([sum (+ sum o)])
                                                                              (w (+ o 1) sum))
                                                                              (w (+ o 1) sum))
                                                                              (printf "\n~a\n" sum)))])
                                                                              (w 1 sum))))])
                                                      (v 1))))])
                              (u 2))))))))])
  (m 2 l)))))))
)

