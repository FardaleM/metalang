#lang racket
(require racket/block)

(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))
(define last-char 0)
(define next-char (lambda () (set! last-char (read-char (current-input-port)))))
(next-char)
(define mread-char (lambda ()
  (let ([ out last-char])
    (block
      (next-char)
      out
    ))))

(define mread-int (lambda ()
  (if (eq? #\- last-char)
  (block
    (next-char) (- 0 (mread-int)))
    (letrec ([w (lambda (out)
      (if (eof-object? last-char)
        out
        (if (and last-char (>= (char->integer last-char) (char->integer #\0)) (<= (char->integer last-char) (char->integer #\9)))
          (let ([out (+ (* 10 out) (- (char->integer last-char) (char->integer #\0)))])
            (block
              (next-char)
              (w out)
          ))
        out
      )))]) (w 0)))))

(define mread-blank (lambda ()
  (if (or (eq? last-char #\NewLine) (eq? last-char #\Space) ) (block (next-char) (mread-blank)) '())
))

(define eratostene (lambda (t_ max_) 
                     (let ([n 0])
                       (let ([bh 2])
                         (let ([bi (- max_ 1)])
                           (letrec ([bd (lambda (i n t_ max_) 
                                          (if (<= i bi)
                                            (let ([be (lambda (n t_ max_) 
                                                        (bd (+ i 1) n t_ max_))])
                                            (if (eq? (vector-ref t_ i) i)
                                              (let ([n (+ n 1)])
                                                (let ([j (* i i)])
                                                  (letrec ([bg (lambda (j n t_ max_) 
                                                                 (if (and (< j max_) (> j 0))
                                                                   (block (vector-set! t_ j 0) 
                                                                   (let ([j (+ j i)])
                                                                    (bg j n t_ max_)))
                                                                   (be n t_ max_)))])
                                                  (bg j n t_ max_))))
                                            (be n t_ max_)))
                             n))])
                       (bd bh n t_ max_)))))))
(define fillPrimesFactors (lambda (t_ n primes nprimes) 
                            (let ([bb 0])
                              (let ([bc (- nprimes 1)])
                                (letrec ([x (lambda (i t_ n primes nprimes) 
                                              (if (<= i bc)
                                                (let ([d (vector-ref primes i)])
                                                  (letrec ([ba (lambda (d t_ n primes nprimes) 
                                                                 (if (eq? (remainder n d) 0)
                                                                   (block (vector-set! t_ d (+ (vector-ref t_ d) 1)) 
                                                                   (let ([n (quotient n d)])
                                                                    (ba d t_ n primes nprimes)))
                                                                   (let ([y 
                                                                    (lambda (d t_ n primes nprimes) 
                                                                    (x (+ i 1) t_ n primes nprimes))])
                                                                   (if (eq? n 1)
                                                                    (vector-ref primes i)
                                                                    (y d t_ n primes nprimes)))))])
                                                (ba d t_ n primes nprimes)))
                                  n))])
                            (x bb t_ n primes nprimes))))))
(define sumdivaux2 (lambda (t_ n i) 
                     (letrec ([w (lambda (t_ n i) 
                                   (if (and (< i n) (eq? (vector-ref t_ i) 0))
                                     (let ([i (+ i 1)])
                                       (w t_ n i))
                                     i))])
                     (w t_ n i))))
(define sumdivaux (lambda (t_ n i) 
                    (let ([f (lambda (t_ n i) 
                               '())])
                    (if (> i n)
                      1
                      (let ([g (lambda (t_ n i) 
                                 (f t_ n i))])
                      (if (eq? (vector-ref t_ i) 0)
                        (sumdivaux t_ n (sumdivaux2 t_ n (+ i 1)))
                        (let ([o (sumdivaux t_ n (sumdivaux2 t_ n (+ i 1)))])
                          (let ([out_ 0])
                            (let ([p i])
                              (let ([m 1])
                                (let ([u (vector-ref t_ i)])
                                  (letrec ([h (lambda (j p out_ o t_ n i) 
                                                (if (<= j u)
                                                  (let ([out_ (+ out_ p)])
                                                    (let ([p (* p i)])
                                                      (h (+ j 1) p out_ o t_ n i)))
                                                  (* (+ out_ 1) o)))])
                                  (h m p out_ o t_ n i)))))))))))))
(define sumdiv (lambda (nprimes primes n) 
                 (let ([a (+ n 1)])
                   (let ([t_ (array_init_withenv a (lambda (i) 
                                                     (lambda (internal_env) (apply (lambda
                                                      (a nprimes primes n) 
                                                     (let ([e 0])
                                                       (list (list a nprimes primes n) e))) internal_env))) (list a nprimes primes n))])
                   (let ([max_ (fillPrimesFactors t_ n primes nprimes)])
                     (sumdivaux t_ max_ 0))))))
(define main (let ([maximumprimes 30001])
               (let ([era (array_init_withenv maximumprimes (lambda (s) 
                                                              (lambda (maximumprimes) 
                                                                (let ([bj s])
                                                                  (list maximumprimes bj)))) maximumprimes)])
  (let ([nprimes (eratostene era maximumprimes)])
    (let ([primes (array_init_withenv nprimes (lambda (t_) 
                                                (lambda (internal_env) (apply (lambda
                                                 (nprimes maximumprimes) 
                                                (let ([bk 0])
                                                  (list (list nprimes maximumprimes) bk))) internal_env))) (list nprimes maximumprimes))])
    (let ([l 0])
      (let ([ce 2])
        (let ([cf (- maximumprimes 1)])
          (letrec ([cc (lambda (k l nprimes maximumprimes) 
                         (if (<= k cf)
                           (let ([cd (lambda (l nprimes maximumprimes) 
                                       (cc (+ k 1) l nprimes maximumprimes))])
                           (if (eq? (vector-ref era k) k)
                             (block (vector-set! primes l k) (let ([l (+ l 1)])
                                                               (cd l nprimes maximumprimes)))
                             (cd l nprimes maximumprimes)))
                         (let ([n 100])
                           ; 28124 Ã§a prend trop de temps mais on arrive a passer le test 
                           (let ([b (+ n 1)])
                             (let ([abondant (array_init_withenv b (lambda (p) 
                                                                    (lambda (internal_env) (apply (lambda
                                                                     (b n l nprimes maximumprimes) 
                                                                    (let ([bl #f])
                                                                    (list (list b n l nprimes maximumprimes) bl))) internal_env))) (list b n l nprimes maximumprimes))])
                             (let ([c (+ n 1)])
                               (let ([summable (array_init_withenv c 
                                 (lambda (q) 
                                   (lambda (internal_env) (apply (lambda
                                    (c b n l nprimes maximumprimes) 
                                   (let ([bm #f])
                                     (list (list c b n l nprimes maximumprimes) bm))) internal_env))) (list c b n l nprimes maximumprimes))])
                               (let ([sum 0])
                                 (let ([ca 2])
                                   (let ([cb n])
                                     (letrec ([by (lambda (r sum c b n l nprimes maximumprimes) 
                                                    (if (<= r cb)
                                                      (let ([other (- (sumdiv nprimes primes r) r)])
                                                        (let ([bz (lambda (other sum c b n l nprimes maximumprimes) 
                                                                    (by (+ r 1) sum c b n l nprimes maximumprimes))])
                                                        (if (> other r)
                                                          (block (vector-set! abondant r #t) (bz other sum c b n l nprimes maximumprimes))
                                                          (bz other sum c b n l nprimes maximumprimes))))
                                                    (let ([bw 1])
                                                      (let ([bx n])
                                                        (letrec ([br 
                                                          (lambda (i sum c b n l nprimes maximumprimes) 
                                                            (if (<= i bx)
                                                              (let ([bu 1])
                                                                (let ([bv n])
                                                                  (letrec ([bs 
                                                                    (lambda (j sum c b n l nprimes maximumprimes) 
                                                                    (if (<= j bv)
                                                                    (let ([bt 
                                                                    (lambda (sum c b n l nprimes maximumprimes) 
                                                                    (bs (+ j 1) sum c b n l nprimes maximumprimes))])
                                                                    (if (and (and (vector-ref abondant i) (vector-ref abondant j)) (<= (+ i j) n))
                                                                    (block (vector-set! summable (+ i j) #t) (bt sum c b n l nprimes maximumprimes))
                                                                    (bt sum c b n l nprimes maximumprimes)))
                                                                    (br (+ i 1) sum c b n l nprimes maximumprimes)))])
                                                                (bs bu sum c b n l nprimes maximumprimes))))
                                                          (let ([bp 1])
                                                            (let ([bq n])
                                                              (letrec ([bn 
                                                                (lambda (o sum c b n l nprimes maximumprimes) 
                                                                  (if (<= o bq)
                                                                    (let ([bo 
                                                                    (lambda (sum c b n l nprimes maximumprimes) 
                                                                    (bn (+ o 1) sum c b n l nprimes maximumprimes))])
                                                                    (if (not (vector-ref summable o))
                                                                    (let ([sum (+ sum o)])
                                                                    (bo sum c b n l nprimes maximumprimes))
                                                                    (bo sum c b n l nprimes maximumprimes)))
                                                                  (block
                                                                    (display "\n")
                                                                    (display sum)
                                                                    (display "\n")
                                                                    )))])
                                                            (bn bp sum c b n l nprimes maximumprimes))))))])
                                     (br bw sum c b n l nprimes maximumprimes))))))])
                         (by ca sum c b n l nprimes maximumprimes))))))))))))])
(cc ce l nprimes maximumprimes))))))))))

