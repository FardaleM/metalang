#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))

(define (eratostene t0 max0)
  ;toto
  (let ([n 0])
  (let ([bf 2])
  (let ([bg (- max0 1)])
  (letrec ([bc (lambda (i n) 
                 (if (<= i bg)
                 (let ([n (if (eq? (vector-ref t0 i) i)
                          (let ([n (+ n 1)])
                          (let ([j (* i i)])
                          (letrec ([be (lambda (j) 
                                         (if (and (< j max0) (> j 0))
                                         (block
                                           (vector-set! t0 j 0)
                                           (let ([j (+ j i)])
                                           (be j))
                                           )
                                         n))])
                          (be j))))
                 n)])
                 (bc (+ i 1) n))
                 n))])
  (bc bf n)))))
)
(define (fillPrimesFactors t0 n primes nprimes)
  ;toto
  (let ([ba 0])
  (let ([bb (- nprimes 1)])
  (letrec ([x (lambda (i n) 
                (if (<= i bb)
                (let ([d (vector-ref primes i)])
                (letrec ([z (lambda (n) 
                              (if (eq? (remainder n d) 0)
                              (block
                                (vector-set! t0 d (+ (vector-ref t0 d) 1))
                                (let ([n (quotient n d)])
                                (z n))
                                )
                              (if (eq? n 1)
                              (vector-ref primes i)
                              (x (+ i 1) n))))])
                (z n)))
                n))])
  (x ba n))))
)
(define (sumdivaux2 t0 n i)
  ;toto
  (letrec ([w (lambda (i) 
                (if (and (< i n) (eq? (vector-ref t0 i) 0))
                (let ([i (+ i 1)])
                (w i))
                i))])
  (w i))
)
(define (sumdivaux t0 n i)
  ;toto
  (let ([f (lambda (_) 
             '())])
  (if (> i n)
  1
  (let ([g (lambda (_) 
             (f 'nil))])
  (if (eq? (vector-ref t0 i) 0)
  (sumdivaux t0 n (sumdivaux2 t0 n (+ i 1)))
  (let ([o (sumdivaux t0 n (sumdivaux2 t0 n (+ i 1)))])
  (let ([out0 0])
  (let ([p i])
  (let ([m 1])
  (let ([u (vector-ref t0 i)])
  (letrec ([h (lambda (j out0 p) 
                (if (<= j u)
                (let ([out0 (+ out0 p)])
                (let ([p (* p i)])
                (h (+ j 1) out0 p)))
                (* (+ out0 1) o)))])
  (h m out0 p)))))))))))
)
(define (sumdiv nprimes primes n)
  ;toto
  (let ([t0 (array_init_withenv (+ n 1) (lambda (i) 
                                          (lambda (_) (let ([e 0])
                                                      (list '() e)))) '())])
  (let ([max0 (fillPrimesFactors t0 n primes nprimes)])
  (sumdivaux t0 max0 0)))
)
(define main
  (let ([maximumprimes 30001])
  (let ([era (array_init_withenv maximumprimes (lambda (s) 
                                                 (lambda (_) (let ([bh s])
                                                             (list '() bh)))) '())])
  (let ([nprimes (eratostene era maximumprimes)])
  (let ([primes (array_init_withenv nprimes (lambda (t0) 
                                              (lambda (_) (let ([bi 0])
                                                          (list '() bi)))) '())])
  (let ([l 0])
  (let ([by 2])
  (let ([bz (- maximumprimes 1)])
  (letrec ([bx (lambda (k l) 
                 (if (<= k bz)
                 (let ([l (if (eq? (vector-ref era k) k)
                          (block
                            (vector-set! primes l k)
                            (let ([l (+ l 1)])
                            l)
                            )
                          l)])
                 (bx (+ k 1) l))
                 (let ([n 100])
                 ; 28124 Ã§a prend trop de temps mais on arrive a passer le test 
                 (let ([abondant (array_init_withenv (+ n 1) (lambda (p) 
                                                               (lambda (_) 
                                                               (let ([bj #f])
                                                               (list '() bj)))) '())])
                 (let ([summable (array_init_withenv (+ n 1) (lambda (q) 
                                                               (lambda (_) 
                                                               (let ([bk #f])
                                                               (list '() bk)))) '())])
                 (let ([sum 0])
                 (let ([bv 2])
                 (let ([bw n])
                 (letrec ([bu (lambda (r) 
                                (if (<= r bw)
                                (let ([other (- (sumdiv nprimes primes r) r)])
                                (block
                                  (if (> other r)
                                  (vector-set! abondant r #t)
                                  '())
                                  (bu (+ r 1))
                                  ))
                                (let ([bs 1])
                                (let ([bt n])
                                (letrec ([bo (lambda (i) 
                                               (if (<= i bt)
                                               (let ([bq 1])
                                               (let ([br n])
                                               (letrec ([bp (lambda (j) 
                                                              (if (<= j br)
                                                              (block
                                                                (if (and (and (vector-ref abondant i) (vector-ref abondant j)) (<= (+ i j) n))
                                                                (vector-set! summable (+ i j) #t)
                                                                '())
                                                                (bp (+ j 1))
                                                                )
                                                              (bo (+ i 1))))])
                                               (bp bq))))
                                               (let ([bm 1])
                                               (let ([bn n])
                                               (letrec ([bl (lambda (o sum) 
                                                              (if (<= o bn)
                                                              (let ([sum 
                                                              (if (not (vector-ref summable o))
                                                              (let ([sum (+ sum o)])
                                                              sum)
                                                              sum)])
                                                              (bl (+ o 1) sum))
                                                              (block
                                                                (map display (list "\n" sum "\n"))
                                                                )))])
                                               (bl bm sum))))))])
                                (bo bs))))))])
                 (bu bv))))))))))])
(bx by l)))))))))
)

