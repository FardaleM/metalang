#lang racket
(require racket/block)

(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))
(define last-char 0)
(define next-char (lambda () (set! last-char (read-char (current-input-port)))))
(next-char)
(define mread-char (lambda ()
  (let ([ out last-char])
    (block
      (next-char)
      out
    ))))

(define mread-int (lambda ()
  (if (eq? #\- last-char)
  (block
    (next-char) (- 0 (mread-int)))
    (letrec ([w (lambda (out)
      (if (eof-object? last-char)
        out
        (if (and last-char (>= (char->integer last-char) (char->integer #\0)) (<= (char->integer last-char) (char->integer #\9)))
          (let ([out (+ (* 10 out) (- (char->integer last-char) (char->integer #\0)))])
            (block
              (next-char)
              (w out)
          ))
        out
      )))]) (w 0)))))

(define mread-blank (lambda ()
  (if (or (eq? last-char #\NewLine) (eq? last-char #\Space) ) (block (next-char) (mread-blank)) '())
))

(define next_ (lambda (n) 
                (let ([e (lambda (n) 
                           '())])
                (if (eq? (remainder n 2) 0)
                  (quotient n 2)
                  (+ (* 3 n) 1)))))
(define find_ (lambda (n m) 
                (let ([b (lambda (n m) 
                           '())])
                (if (eq? n 1)
                  1
                  (let ([c (lambda (n m) 
                             (b n m))])
                  (if (>= n 1000000)
                    (+ 1 (find_ (next_ n) m))
                    (let ([d (lambda (n m) 
                               (c n m))])
                    (if (not (eq? (vector-ref m n) 0))
                      (vector-ref m n)
                      (block
                        (vector-set! m n (+ 1 (find_ (next_ n) m)))
                        (vector-ref m n)
                        )))))))))
(define main (let ([a 1000000])
               (let ([m (array_init_withenv a (lambda (j) 
                                                (lambda (a) 
                                                  (let ([f 0])
                                                    (list a f)))) a)])
  (let ([max_ 0])
    (let ([maxi 0])
      (let ([k 1])
        (let ([l 999])
          (letrec ([g (lambda (i maxi max_ a) 
                        (if (<= i l)
                          ; normalement on met 999999 mais ça dépasse les int32... 
                          (let ([n2 (find_ i m)])
                            (let ([h (lambda (n2 maxi max_ a) 
                                       (g (+ i 1) maxi max_ a))])
                            (if (> n2 max_)
                              (let ([max_ n2])
                                (let ([maxi i])
                                  (h n2 maxi max_ a)))
                              (h n2 maxi max_ a))))
                        (block
                          (display max_)
                          (display "\n")
                          (display maxi)
                          (display "\n")
                          )))])
        (g k maxi max_ a)))))))))

