#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))

(define (next_ n)
  ;toto
  (let ([d (lambda (_) 
             '())])
  (if (eq? (remainder n 2) 0)
  (quotient n 2)
  (+ (* 3 n) 1)))
)
(define (find_ n m)
  ;toto
  (let ([a (lambda (_) 
             '())])
  (if (eq? n 1)
  1
  (let ([b (lambda (_) 
             (a 'nil))])
  (if (>= n 1000000)
  (+ 1 (find_ (next_ n) m))
  (let ([c (lambda (_) 
             (b 'nil))])
  (if (not (eq? (vector-ref m n) 0))
  (vector-ref m n)
  (block
    (vector-set! m n (+ 1 (find_ (next_ n) m)))
    (vector-ref m n)
    )))))))
)
(define main
  (let ([m (array_init_withenv 1000000 (lambda (j) 
                                         (lambda (_) (let ([e 0])
                                                     (list '() e)))) '())])
  (let ([max_ 0])
  (let ([maxi 0])
  (let ([g 1])
  (let ([h 999])
  (letrec ([f (lambda (i max_ maxi) 
                (if (<= i h)
                ; normalement on met 999999 mais ça dépasse les int32... 
                (let ([n2 (find_ i m)])
                ((lambda (internal_env) (apply (lambda (max_ maxi) 
                                                      (f (+ i 1) max_ maxi)) internal_env)) 
                (if (> n2 max_)
                (let ([max_ n2])
                (let ([maxi i])
                (list max_ maxi)))
                (list max_ maxi))))
                (block
                  (map display (list max_ "\n" maxi "\n"))
                  )))])
  (f g max_ maxi)))))))
)

