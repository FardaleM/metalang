#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))

(define next_ (lambda (n) 
                (let ([e (lambda (_) 
                           '())])
                (if (eq? (remainder n 2) 0)
                  (quotient n 2)
                  (+ (* 3 n) 1)))))
(define find_ (lambda (n m) 
                (let ([b (lambda (_) 
                           '())])
                (if (eq? n 1)
                  1
                  (let ([c (lambda (_) 
                             (b 'nil))])
                  (if (>= n 1000000)
                    (+ 1 (find_ (next_ n) m))
                    (let ([d (lambda (_) 
                               (c 'nil))])
                    (if (not (eq? (vector-ref m n) 0))
                      (vector-ref m n)
                      (block
                        (vector-set! m n (+ 1 (find_ (next_ n) m)))
                        (vector-ref m n)
                        )))))))))
(define main (let ([a 1000000])
               (let ([m (array_init_withenv a (lambda (j) 
                                                (lambda (_) (let ([f 0])
                                                              (list '() f)))) '())])
               (let ([max_ 0])
                 (let ([maxi 0])
                   (let ([h 1])
                     (let ([k 999])
                       (letrec ([g (lambda (i max_ maxi) 
                                     (if (<= i k)
                                       ; normalement on met 999999 mais ça dépasse les int32... 
                                       (let ([n2 (find_ i m)])
                                         ((lambda (internal_env) (apply (lambda
                                          (max_ maxi) 
                                         (g (+ i 1) max_ maxi)) internal_env)) 
                                         (if (> n2 max_)
                                           (let ([max_ n2])
                                             (let ([maxi i])
                                               (list max_ maxi)))
                                           (list max_ maxi))))
                                       (block
                                         (display max_)
                                         (display "\n")
                                         (display maxi)
                                         (display "\n")
                                         )))])
                       (g h max_ maxi)))))))))

