#lang racket
(require racket/block)

(define (pgcd a b)
  ;toto
  (let ([c (min a b)])
  (let ([d (max a b)])
  (let ([reste (remainder d c)])
  (let ([e (lambda (_) 
             '())])
  (if (eq? reste 0)
  c
  (pgcd c reste))))))
)
(define main
  (let ([top 1])
  (let ([bottom 1])
  (let ([q 1])
  (let ([r 9])
  (letrec ([f (lambda (i bottom top) 
                (if (<= i r)
                (let ([n 1])
                (let ([o 9])
                (letrec ([g (lambda (j bottom top) 
                              (if (<= j o)
                              (let ([l 1])
                              (let ([m 9])
                              (letrec ([h (lambda (k bottom top) 
                                            (if (<= k m)
                                            ((lambda (internal_env) (apply (lambda
                                             (bottom top) 
                                            (h (+ k 1) bottom top)) internal_env)) 
                                            (if (and (not (eq? i j)) (not (eq? j k)))
                                            (let ([a (+ (* i 10) j)])
                                            (let ([b (+ (* j 10) k)])
                                            ((lambda (internal_env) (apply (lambda
                                             (bottom top) 
                                            (list bottom top)) internal_env)) 
                                            (if (eq? (* a k) (* i b))
                                            (block
                                              (map display (list a "/" b "\n"))
                                              (let ([top (* top a)])
                                              (let ([bottom (* bottom b)])
                                              (list bottom top)))
                                              )
                                            (list bottom top)))))
                                            (list bottom top)))
                                            (g (+ j 1) bottom top)))])
                              (h l bottom top))))
                              (f (+ i 1) bottom top)))])
                (g n bottom top))))
    (block
      (map display (list top "/" bottom "\n"))
      (let ([p (pgcd top bottom)])
      (block
        (map display (list "pgcd=" p "\n" (quotient bottom p) "\n"))
        ))
      )))])
  (f q bottom top))))))
)

