#lang racket
(require racket/block)

(define (max2 a b)
  ;toto
  (let ([g (lambda (_) 
             '())])
  (if (> a b)
  a
  b))
)
(define (min2 a b)
  ;toto
  (let ([f (lambda (_) 
             '())])
  (if (< a b)
  a
  b))
)
(define (pgcd a b)
  ;toto
  (let ([c (min2 a b)])
  (let ([d (max2 a b)])
  (let ([reste (remainder d c)])
  (let ([e (lambda (_) 
             '())])
  (if (eq? reste 0)
  c
  (pgcd c reste))))))
)
(define main
  (let ([top 1])
  (let ([bottom 1])
  (let ([s 1])
  (let ([u 9])
  (letrec ([h (lambda (i bottom top) 
                (if (<= i u)
                (let ([q 1])
                (let ([r 9])
                (letrec ([l (lambda (j bottom top) 
                              (if (<= j r)
                              (let ([n 1])
                              (let ([o 9])
                              (letrec ([m (lambda (k bottom top) 
                                            (if (<= k o)
                                            ((lambda (internal_env) (apply (lambda
                                             (bottom top) 
                                            (m (+ k 1) bottom top)) internal_env)) 
                                            (if (and (not (eq? i j)) (not (eq? j k)))
                                            (let ([a (+ (* i 10) j)])
                                            (let ([b (+ (* j 10) k)])
                                            ((lambda (internal_env) (apply (lambda
                                             (bottom top) 
                                            (list bottom top)) internal_env)) 
                                            (if (eq? (* a k) (* i b))
                                            (block
                                              (display a)
                                              (display "/")
                                              (display b)
                                              (display "\n")
                                              (let ([top (* top a)])
                                              (let ([bottom (* bottom b)])
                                              (list bottom top)))
                                              )
                                            (list bottom top)))))
                                            (list bottom top)))
                                            (l (+ j 1) bottom top)))])
                              (m n bottom top))))
                              (h (+ i 1) bottom top)))])
                (l q bottom top))))
    (block
      (display top)
      (display "/")
      (display bottom)
      (display "\n")
      (let ([p (pgcd top bottom)])
      (block
        (display "pgcd=")
        (display p)
        (display "\n")
        (display (quotient bottom p))
        (display "\n")
        ))
      )))])
  (h s bottom top))))))
)

