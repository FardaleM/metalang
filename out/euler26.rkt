#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))

(define (periode restes len a b)
  ;toto
  (letrec ([e (lambda (a len) 
                (if (not (eq? a 0))
                (let ([chiffre (quotient a b)])
                (let ([reste (remainder a b)])
                (let ([g 0])
                (let ([h (- len 1)])
                (letrec ([f (lambda (i) 
                              (if (<= i h)
                              (if (eq? (vector-ref restes i) reste)
                              (- len i)
                              (f (+ i 1)))
                              (block
                                (vector-set! restes len reste)
                                (let ([len (+ len 1)])
                                (let ([a (* reste 10)])
                                (e a len)))
                                )))])
                (f g))))))
                0))])
(e a len))
)
(define main
  (let ([c 1000])
  (let ([t_ (array_init_withenv c (lambda (j) 
                                    (lambda (_) (let ([k 0])
                                                (list '() k)))) '())])
  (let ([m 0])
  (let ([mi 0])
  (let ([n 1])
  (let ([o 1000])
  (letrec ([l (lambda (i m mi) 
                (if (<= i o)
                (let ([p (periode t_ 0 1 i)])
                ((lambda (internal_env) (apply (lambda (m mi) 
                                                      (l (+ i 1) m mi)) internal_env)) 
                (if (> p m)
                (let ([mi i])
                (let ([m p])
                (list m mi)))
                (list m mi))))
                (block
                  (display mi)
                  (display "\n")
                  (display m)
                  (display "\n")
                  )))])
  (l n m mi))))))))
)

