#lang racket
(require racket/block)

(define (periode restes len a b)
  (letrec ([c (lambda (a len) 
                (if (not (eq? a 0))
                (let ([chiffre (quotient a b)])
                (let ([reste (remainder a b)])
                (letrec ([d (lambda (i) 
                              (if (<= i (- len 1))
                              (if (eq? (vector-ref restes i) reste)
                              (- len i)
                              (d (+ i 1)))
                              (block
                                (vector-set! restes len reste)
                                (let ([len (+ len 1)])
                                (let ([a (* reste 10)])
                                (c a len)))
                                )))])
                (d 0))))
                0))])
(c a len))
)
(define main
  (let ([t0 (build-vector 1000 (lambda (j) 
                                 0))])
  (let ([m 0])
  (let ([mi 0])
  (letrec ([e (lambda (i m mi) 
                (if (<= i 1000)
                (let ([p (periode t0 0 1 i)])
                (if (> p m)
                (let ([mi i])
                (let ([m p])
                (e (+ i 1) m mi)))
                (e (+ i 1) m mi)))
                (printf "~a\n~a\n" mi m)))])
  (e 1 m mi)))))
)

