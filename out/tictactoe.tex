\documentclass[8pt]{article}
\usepackage[ruled,vlined]{algorithm2e}
\title{tictactoe}
\begin{document}
\maketitle

Tictactoe : un tictactoe avec une IA

 La structure de donn\'ee 
record gamestate array<array<int>> cases;
bool firstToPlay;
int note;
bool ended;

end

 Un Mouvement 
record move int x;
int y;

end

 On affiche l'\'etat 
\begin{algorithm}[H]
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{g:@gamestate}
\Output{void}

$print_{string}$($ "
|" $)\;
\For{ $y\;:=\;0\; to\;2$}{
                            \For{ $x\;:=\;0\; to\;2$}{
                                                        \If{ $ g.cases[x][y] = 0 $ }{
                                                          $print_{string}$($ " " $)\;
                                                        }
                                                        \Else{
                                                          \If{ $ g.cases[x][y] = 1 $ }{
                                                            $print_{string}$($ "O" $)\;
                                                          }
                                                          \Else{
                                                            $print_{string}$($ "X" $)\;
                                                          }
                                                        }
                                                        $print_{string}$($ "|" $)\;}
                            
                            \If{ $ y \neq 2 $ }{
                              $print_{string}$($ "
|-|-|-|
|" $)\;
                            }
                            }

$print_{string}$($ "
" $)\;
\caption{print\_state}
\end{algorithm}
 On dit qui gagne (info stoqu\'ees dans g.ended et g.note ) 
\begin{algorithm}[H]
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{g:@gamestate}
\Output{void}

$int\:win := 0$\;
$int\:freecase := 0$\;
\For{ $y\;:=\;0\; to\;2$}{
                            $int\:col := -1$\;
                            $int\:lin := -1$\;
                            \For{ $x\;:=\;0\; to\;2$}{
                                                        \If{ $ g.cases[x][y] = 0 $ }{
                                                          freecase ++;
                                                        }
                                                        
                                                        $int\:colv := g.cases[x][y]$\;
                                                        $int\:linv := g.cases[y][x]$\;
                                                        \If{ $ col = -1 and colv \neq 0 $ }{
                                                          $col \leftarrow colv $\;
                                                        }
                                                        \Else{
                                                          \If{ $ colv \neq col $ }{
                                                            $col \leftarrow -2 $\;
                                                          }
                                                          
                                                        }
                                                        \If{ $ lin = -1 and linv \neq 0 $ }{
                                                          $lin \leftarrow linv $\;
                                                        }
                                                        \Else{
                                                          \If{ $ linv \neq lin $ }{
                                                            $lin \leftarrow -2 $\;
                                                          }
                                                          
                                                        }}
                            
                            \If{ $ col \geq 0 $ }{
                              $win \leftarrow col $\;
                            }
                            \Else{
                              \If{ $ lin \geq 0 $ }{
                                $win \leftarrow lin $\;
                              }
                              
                            }}

\For{ $x\;:=\;1\; to\;2$}{
                            \If{ $ g.cases[0][0] = x and g.cases[1][1] = x and g.cases[2][2] = x $ }{
                              $win \leftarrow x $\;
                            }
                            
                            \If{ $ g.cases[0][2] = x and g.cases[1][1] = x and g.cases[2][0] = x $ }{
                              $win \leftarrow x $\;
                            }
                            }

$g.ended \leftarrow win \neq 0 or freecase = 0 $\;
\If{ $ win = 1 $ }{
  $g.note \leftarrow 1000 $\;
}
\Else{
  \If{ $ win = 2 $ }{
    $g.note \leftarrow -1000 $\;
  }
  \Else{
    $g.note \leftarrow 0 $\;
  }
}
\caption{eval}
\end{algorithm}
 On applique un mouvement 
\begin{algorithm}[H]
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{x:int,
y:int,
g:@gamestate}
\Output{void}
$int\:player := 2$\;
\If{ $ g.firstToPlay $ }{
  $player \leftarrow 1 $\;
}

$g.cases[x][y] \leftarrow player $\;
$g.firstToPlay \leftarrow !g.firstToPlay $\;
\caption{apply\_move\_xy}
\end{algorithm}
\begin{algorithm}[H]
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{m:@move,
g:@gamestate}
\Output{void}
$apply_move_xy(m.x, m.y, g)$\;
\caption{apply\_move}
\end{algorithm}
\begin{algorithm}[H]
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{x:int,
y:int,
g:@gamestate}
\Output{void}
$g.cases[x][y] \leftarrow 0 $\;
$g.firstToPlay \leftarrow !g.firstToPlay $\;
$g.ended \leftarrow false $\;
\caption{cancel\_move\_xy}
\end{algorithm}
\begin{algorithm}[H]
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{m:@move,
g:@gamestate}
\Output{void}
$cancel_move_xy(m.x, m.y, g)$\;
\caption{cancel\_move}
\end{algorithm}
\begin{algorithm}[H]
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{x:int,
y:int,
g:@gamestate}
\Output{bool}
\Return $ g.cases[x][y] = 0 $\;
\caption{can\_move\_xy}
\end{algorithm}
\begin{algorithm}[H]
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{m:@move,
g:@gamestate}
\Output{bool}
\Return $ can_move_xy(m.x, m.y, g) $\;
\caption{can\_move}
\end{algorithm}

Un minimax classique, renvoie la note du plateau

\begin{algorithm}[H]
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{g:@gamestate}
\Output{int}

$eval(g)$\;
\If{ $ g.ended $ }{
  \Return $ g.note $\;
}

$int\:maxNote := -10000$\;
\If{ $ !g.firstToPlay $ }{
  $maxNote \leftarrow 10000 $\;
}

\For{ $x\;:=\;0\; to\;2$}{
                            \For{ $y\;:=\;0\; to\;2$}{
                                                        \If{ $ can_move_xy(x, y, g) $ }{
                                                          $apply_move_xy(x, y, g)$\;
                                                          $int\:currentNote := minmax(g)$\;
                                                          $cancel_move_xy(x, y, g)$\;
                                                          \tcc*[f]{\emph{ Minimum ou Maximum selon le cot\'e ou l'on joue}}\;
                                                          \If{ $ (currentNote > maxNote) = g.firstToPlay $ }{
                                                            $maxNote \leftarrow currentNote $\;
                                                          }
                                                          
                                                        }
                                                        }
                            }

\Return $ maxNote $\;
\caption{minmax}
\end{algorithm}

Renvoie le coup de l'IA

\begin{algorithm}[H]
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{g:@gamestate}
\Output{@move}
def @move minMove = with x = $ 0 $
y = $ 0 $ end
$int\:minNote := 10000$\;
\For{ $x\;:=\;0\; to\;2$}{
                            \For{ $y\;:=\;0\; to\;2$}{
                                                        \If{ $ can_move_xy(x, y, g) $ }{
                                                          $apply_move_xy(x, y, g)$\;
                                                          $int\:currentNote := minmax(g)$\;
                                                          $print_{int}$($ x $)\;
                                                          $print_{string}$($ ", " $)\;
                                                          $print_{int}$($ y $)\;
                                                          $print_{string}$($ ", " $)\;
                                                          $print_{int}$($ currentNote $)\;
                                                          $print_{string}$($ "
" $)\;
                                                          $cancel_move_xy(x, y, g)$\;
                                                          \If{ $ currentNote < minNote $ }{
                                                            $minNote \leftarrow currentNote $\;
                                                            $minMove.x \leftarrow x $\;
                                                            $minMove.y \leftarrow y $\;
                                                          }
                                                          
                                                        }
                                                        }
                            }

$print_{int}$($ minMove.x $)\;
$print_{int}$($ minMove.y $)\;
$print_{string}$($ "
" $)\;
\Return $ minMove $\;
\caption{play}
\end{algorithm}
\begin{algorithm}[H]
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{}
\Output{@gamestate}

$array<array<int>>\:cases=\:new\:array<int>[3]$\;
\ForEach{ $i\;indice\;of\;cases$ }{$array<int>\:tab=\:new\:int[3]$\;
\ForEach{ $j\;indice\;of\;tab$ }{$tab[j]:=0$}
$cases[i]:=tab$}
def @gamestate out = with cases = $ cases $
firstToPlay = $ true $
note = $ 0 $
ended = $ false $ end
\Return $ out $\;
\caption{init}
\end{algorithm}
\begin{algorithm}[H]
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{}
\Output{@move}

def read int x
read\_blank(STDIN)\;
def read int y
read\_blank(STDIN)\;
def @move out = with x = $ x $
y = $ y $ end
\Return $ out $\;
\caption{read\_move}
\end{algorithm}

\begin{algorithm}[H]
\For{ $i\;:=\;0\; to\;1$}{
                                                  $@gamestate\:state := init()$\;
                                                  \While{$ !state.ended $}{
                                                    $print_state(state)$\;
                                                    $apply_move(play(state), state)$\;
                                                    $eval(state)$\;
                                                    $print_state(state)$\;
                                                    \If{ $ !state.ended $ }{
                                                      $apply_move(play(state), state)$\;
                                                      $eval(state)$\;
                                                    }
                                                    
                                                  }
                                                  $print_state(state)$\;
                                                  $print_{int}$($ state.note $)\;
                                                  $print_{string}$($ "
" $)\;}

\caption{Main}
\end{algorithm}
\end{document}

