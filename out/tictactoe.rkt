#lang racket
(require racket/block)

(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))
(define last-char 0)
(define next-char (lambda () (set! last-char (read-char (current-input-port)))))
(next-char)
(define mread-char (lambda ()
  (let ([ out last-char])
    (block
      (next-char)
      out
    ))))

(define mread-int (lambda ()
  (if (eq? #\- last-char)
  (block
    (next-char) (- 0 (mread-int)))
    (letrec ([w (lambda (out)
      (if (eof-object? last-char)
        out
        (if (and last-char (>= (char->integer last-char) (char->integer #\0)) (<= (char->integer last-char) (char->integer #\9)))
          (let ([out (+ (* 10 out) (- (char->integer last-char) (char->integer #\0)))])
            (block
              (next-char)
              (w out)
          ))
        out
      )))]) (w 0)))))

(define mread-blank (lambda ()
  (if (or (eq? last-char #\NewLine) (eq? last-char #\Space) ) (block (next-char) (mread-blank)) '())
))

(struct gamestate ([cases #:mutable] [ended #:mutable] [firstToPlay #:mutable] [note #:mutable]))
(struct move ([x #:mutable] [y #:mutable]))
(define print_state (lambda (g) 
                      (block
                        (display "\n|")
                        (let ([cf 0])
                          (let ([cg 2])
                            (letrec ([by (lambda (y g) 
                                           (if (<= y cg)
                                             (let ([cd 0])
                                               (let ([ce 2])
                                                 (letrec ([ca (lambda (x g) 
                                                                (if (<= x ce)
                                                                  (let ([cb 
                                                                    (lambda (g) 
                                                                    (block
                                                                    (display "|")
                                                                    (ca (+ x 1) g)
                                                                    ))])
                                                                  (if (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 0)
                                                                    (block
                                                                    (display " ")
                                                                    (cb g)
                                                                    )
                                                                    (let ([cc 
                                                                    (lambda (g) 
                                                                    (cb g))])
                                                                    (if (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 1)
                                                                    (block
                                                                    (display "O")
                                                                    (cc g)
                                                                    )
                                                                    (block
                                                                    (display "X")
                                                                    (cc g)
                                                                    )))))
                                                   (let ([bz (lambda (g) 
                                                               (by (+ y 1) g))])
                                                   (if (not (eq? y 2))
                                                     (block
                                                       (display "\n|-|-|-|\n|")
                                                       (bz g)
                                                       )
                                                     (bz g)))))])
                                           (ca cd g))))
                          (display "\n")))])
  (by cf g))))
)))
(define eval_ (lambda (g) 
                (let ([win 0])
                  (let ([freecase 0])
                    (let ([bw 0])
                      (let ([bx 2])
                        (letrec ([bl (lambda (y freecase win g) 
                                       (if (<= y bx)
                                         (let ([col (- 1)])
                                           (let ([lin (- 1)])
                                             (let ([bu 0])
                                               (let ([bv 2])
                                                 (letrec ([bo (lambda (x lin col freecase win g) 
                                                                (if (<= x bv)
                                                                  (let ([bt 
                                                                    (lambda (lin col freecase win g) 
                                                                    (let ([colv (vector-ref (vector-ref (gamestate-cases g) x) y)])
                                                                    (let ([linv (vector-ref (vector-ref (gamestate-cases g) y) x)])
                                                                    (let ([br 
                                                                    (lambda (linv colv lin col freecase win g) 
                                                                    (let ([bp 
                                                                    (lambda (linv colv lin col freecase win g) 
                                                                    (bo (+ x 1) lin col freecase win g))])
                                                                    (if (and (eq? lin (- 1)) (not (eq? linv 0)))
                                                                    (let ([lin linv])
                                                                    (bp linv colv lin col freecase win g))
                                                                    (let ([bq 
                                                                    (lambda (linv colv lin col freecase win g) 
                                                                    (bp linv colv lin col freecase win g))])
                                                                    (if (not (eq? linv lin))
                                                                    (let ([lin (- 2)])
                                                                    (bq linv colv lin col freecase win g))
                                                                    (bq linv colv lin col freecase win g))))))])
                                                                    (if (and (eq? col (- 1)) (not (eq? colv 0)))
                                                                    (let ([col colv])
                                                                    (br linv colv lin col freecase win g))
                                                                    (let ([bs 
                                                                    (lambda (linv colv lin col freecase win g) 
                                                                    (br linv colv lin col freecase win g))])
                                                                    (if (not (eq? colv col))
                                                                    (let ([col (- 2)])
                                                                    (bs linv colv lin col freecase win g))
                                                                    (bs linv colv lin col freecase win g))))))))])
                                               (if (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 0)
                                                 (let ([freecase (+ freecase 1)])
                                                   (bt lin col freecase win g))
                                                 (bt lin col freecase win g)))
                                             (let ([bm (lambda (lin col freecase win g) 
                                                         (bl (+ y 1) freecase win g))])
                                             (if (>= col 0)
                                               (let ([win col])
                                                 (bm lin col freecase win g))
                                               (let ([bn (lambda (lin col freecase win g) 
                                                           (bm lin col freecase win g))])
                                               (if (>= lin 0)
                                                 (let ([win lin])
                                                   (bn lin col freecase win g))
                                                 (bn lin col freecase win g)))))))])
                        (bo bu lin col freecase win g))))))
  (let ([bj 1])
    (let ([bk 2])
      (letrec ([bg (lambda (x freecase win g) 
                     (if (<= x bk)
                       (let ([bi (lambda (freecase win g) 
                                   (let ([bh (lambda (freecase win g) 
                                               (bg (+ x 1) freecase win g))])
                                   (if (and (and (eq? (vector-ref (vector-ref (gamestate-cases g) 0) 2) x) (eq? (vector-ref (vector-ref (gamestate-cases g) 1) 1) x)) (eq? (vector-ref (vector-ref (gamestate-cases g) 2) 0) x))
                                     (let ([win x])
                                       (bh freecase win g))
                                     (bh freecase win g))))])
                     (if (and (and (eq? (vector-ref (vector-ref (gamestate-cases g) 0) 0) x) (eq? (vector-ref (vector-ref (gamestate-cases g) 1) 1) x)) (eq? (vector-ref (vector-ref (gamestate-cases g) 2) 2) x))
                       (let ([win x])
                         (bi freecase win g))
                       (bi freecase win g)))
        (block
          (set-gamestate-ended! g (or (not (eq? win 0)) (eq? freecase 0)))
          (let ([be (lambda (freecase win g) 
                      '())])
          (if (eq? win 1)
            (block
              (set-gamestate-note! g 1000)
              (be freecase win g)
              )
            (let ([bf (lambda (freecase win g) 
                        (be freecase win g))])
            (if (eq? win 2)
              (block
                (set-gamestate-note! g (- 1000))
                (bf freecase win g)
                )
              (block
                (set-gamestate-note! g 0)
                (bf freecase win g)
                )))))
      )))])
(bg bj freecase win g))))))])
(bl bw freecase win g))))))))
(define apply_move_xy (lambda (x y g) 
                        (let ([player 2])
                          (let ([bd (lambda (player x y g) 
                                      (block
                                        (vector-set! (vector-ref (gamestate-cases g) x) y player)
                                        (set-gamestate-firstToPlay! g (not (gamestate-firstToPlay g)))
                                        '()
                                        ))])
                          (if (gamestate-firstToPlay g)
                            (let ([player 1])
                              (bd player x y g))
                            (bd player x y g))))))
(define apply_move (lambda (m g) 
                     (block
                       (apply_move_xy (move-x m) (move-y m) g)
                       '()
                       )))
(define cancel_move_xy (lambda (x y g) 
                         (block
                           (vector-set! (vector-ref (gamestate-cases g) x) y 0)
                           (set-gamestate-firstToPlay! g (not (gamestate-firstToPlay g)))
                           (set-gamestate-ended! g #f)
                           '()
                           )))
(define cancel_move (lambda (m g) 
                      (block
                        (cancel_move_xy (move-x m) (move-y m) g)
                        '()
                        )))
(define can_move_xy (lambda (x y g) 
                      (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 0)))
(define can_move (lambda (m g) 
                   (can_move_xy (move-x m) (move-y m) g)))
(define minmax (lambda (g) 
                 (block
                   (eval_ g)
                   (let ([bc (lambda (g) 
                               (let ([maxNote (- 10000)])
                                 (let ([bb (lambda (maxNote g) 
                                             (let ([z 0])
                                               (let ([ba 2])
                                                 (letrec ([q (lambda (x maxNote g) 
                                                               (if (<= x ba)
                                                                 (let ([v 0])
                                                                   (let ([w 2])
                                                                    (letrec ([r 
                                                                    (lambda (y maxNote g) 
                                                                    (if (<= y w)
                                                                    (let ([s 
                                                                    (lambda (maxNote g) 
                                                                    (r (+ y 1) maxNote g))])
                                                                    (if (can_move_xy x y g)
                                                                    (block
                                                                    (apply_move_xy x y g)
                                                                    (let ([currentNote (minmax g)])
                                                                    (block
                                                                    (cancel_move_xy x y g)
                                                                    ; Minimum ou Maximum selon le coté ou l'on joue
                                                                    (let ([u 
                                                                    (lambda (currentNote maxNote g) 
                                                                    (s maxNote g))])
                                                                    (if (eq? (> currentNote maxNote) (gamestate-firstToPlay g))
                                                                    (let ([maxNote currentNote])
                                                                    (u currentNote maxNote g))
                                                                    (u currentNote maxNote g)))
                                                                    ))
                                                                    )
                                                                    (s maxNote g)))
                                                                    (q (+ x 1) maxNote g)))])
                                                                 (r v maxNote g))))
                                                 maxNote))])
                                   (q z maxNote g)))))])
                 (if (not (gamestate-firstToPlay g))
                   (let ([maxNote 10000])
                     (bb maxNote g))
                   (bb maxNote g)))))])
(if (gamestate-ended g)
  (gamestate-note g)
  (bc g)))
)))
(define play (lambda (g) 
               (let ([minMove (move 0 0)])
                 (let ([minNote 10000])
                   (let ([o 0])
                     (let ([p 2])
                       (letrec ([e (lambda (x minNote minMove g) 
                                     (if (<= x p)
                                       (let ([l 0])
                                         (let ([n 2])
                                           (letrec ([f (lambda (y minNote minMove g) 
                                                         (if (<= y n)
                                                           (let ([h (lambda (minNote minMove g) 
                                                                    (f (+ y 1) minNote minMove g))])
                                                           (if (can_move_xy x y g)
                                                             (block
                                                               (apply_move_xy x y g)
                                                               (let ([currentNote (minmax g)])
                                                                 (block
                                                                   (display x)
                                                                   (display ", ")
                                                                   (display y)
                                                                   (display ", ")
                                                                   (display currentNote)
                                                                   (display "\n")
                                                                   (cancel_move_xy x y g)
                                                                   (let ([k 
                                                                    (lambda (currentNote minNote minMove g) 
                                                                    (h minNote minMove g))])
                                                                   (if (< currentNote minNote)
                                                                    (let ([minNote currentNote])
                                                                    (block
                                                                    (set-move-x! minMove x)
                                                                    (set-move-y! minMove y)
                                                                    (k currentNote minNote minMove g)
                                                                    ))
                                                                    (k currentNote minNote minMove g)))
                                                                 ))
                                                             )
                                                           (h minNote minMove g)))
                                             (e (+ x 1) minNote minMove g)))])
                                       (f l minNote minMove g))))
                       (block
                         (display (move-x minMove))
                         (display (move-y minMove))
                         (display "\n")
                         minMove
                         )))])
                 (e o minNote minMove g))))))))
(define init_ (lambda () 
                (let ([b 3])
                  (let ([cases (array_init_withenv b (lambda (i) 
                                                       (lambda (b) 
                                                         (let ([a 3])
                                                           (let ([tab (array_init_withenv a 
                                                             (lambda (j) 
                                                               (lambda (internal_env) (apply (lambda
                                                                (a i b) 
                                                               (let ([d 0])
                                                                 (list (list a i b) d))) internal_env))) (list a i b))])
                                                           (let ([c tab])
                                                             (list b c)))))) b)])
  (gamestate cases #f #t 0)))))
(define read_move (lambda () 
                    ((lambda (x) 
                       (block (mread-blank) ((lambda (y) 
                                               (block (mread-blank) (move x y) )) (mread-int)) )) (mread-int))))
(define main (let ([cl 0])
               (let ([cm 1])
                 (letrec ([ch (lambda (i) 
                                (if (<= i cm)
                                  (let ([state (init_ )])
                                    (block
                                      (apply_move (move 1 1) state)
                                      (apply_move (move 0 0) state)
                                      (letrec ([cj (lambda (state) 
                                                     (if (not (gamestate-ended state))
                                                       (block
                                                         (print_state state)
                                                         (apply_move (play state) state)
                                                         (eval_ state)
                                                         (print_state state)
                                                         (let ([ck (lambda (state) 
                                                                    (cj state))])
                                                         (if (not (gamestate-ended state))
                                                           (block
                                                             (apply_move (play state) state)
                                                             (eval_ state)
                                                             (ck state)
                                                             )
                                                           (ck state)))
                                                       )
                                                     (block
                                                       (print_state state)
                                                       (display (gamestate-note state))
                                                       (display "\n")
                                                       (ch (+ i 1))
                                                       )))])
                                    (cj state))
                                  ))
                   '()))])
  (ch cl)))))

