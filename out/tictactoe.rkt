#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (let ((tab (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    ))))) (list env tab))))
(define last-char 0)
(define next-char (lambda () (set! last-char (read-char (current-input-port)))))
(next-char)
(define mread-int (lambda ()
  (if (eq? #\- last-char)
  (block
    (next-char) (- 0 (mread-int)))
    (letrec ([w (lambda (out)
      (if (eof-object? last-char)
        out
        (if (and last-char (>= (char->integer last-char) (char->integer #\0)) (<= (char->integer last-char) (char->integer #\9)))
          (let ([out (+ (* 10 out) (- (char->integer last-char) (char->integer #\0)))])
            (block
              (next-char)
              (w out)
          ))
        out
      )))]) (w 0)))))
(define mread-blank (lambda ()
  (if (or (eq? last-char #\NewLine) (eq? last-char #\Space) ) (block (next-char) (mread-blank)) '())
))

(struct gamestate ([cases #:mutable] [ended #:mutable] [firstToPlay #:mutable] [note #:mutable]))
(struct move ([x #:mutable] [y #:mutable]))
(define (print_state g)
  ;toto
  (block
    (display "\n|")
    (let ([bk 0])
    (let ([bl 2])
    (letrec ([bg (lambda (y) 
                   (if (<= y bl)
                   (let ([bi 0])
                   (let ([bj 2])
                   (letrec ([bh (lambda (x) 
                                  (if (<= x bj)
                                  (block
                                    (if (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 0)
                                    (display " ")
                                    (block
                                      (if (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 1)
                                      (display "O")
                                      (display "X"))
                                      '()
                                      ))
                                    (display "|")
                                    (bh (+ x 1))
                                    )
                                  (block
                                    (if (not (eq? y 2))
                                    (display "\n|-|-|-|\n|")
                                    '())
                                    (bg (+ y 1))
                                    )))])
                   (bh bi))))
                   (display "\n")))])
    (bg bk))))
)
)
(define (eval0 g)
  ;toto
  (let ([win 0])
  (let ([freecase 0])
  (let ([be 0])
  (let ([bf 2])
  (letrec ([ba (lambda (y freecase win) 
                 (if (<= y bf)
                 (let ([col (- 1)])
                 (let ([lin (- 1)])
                 (let ([bc 0])
                 (let ([bd 2])
                 (letrec ([bb (lambda (x col freecase lin) 
                                (if (<= x bd)
                                (let ([freecase (if (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 0)
                                                (let ([freecase (+ freecase 1)])
                                                freecase)
                                                freecase)])
                                (let ([colv (vector-ref (vector-ref (gamestate-cases g) x) y)])
                                (let ([linv (vector-ref (vector-ref (gamestate-cases g) y) x)])
                                (let ([col (if (and (eq? col (- 1)) (not (eq? colv 0)))
                                           (let ([col colv])
                                           col)
                                           (let ([col (if (not (eq? colv col))
                                                      (let ([col (- 2)])
                                                      col)
                                                      col)])
                                           col))])
                                (let ([lin (if (and (eq? lin (- 1)) (not (eq? linv 0)))
                                           (let ([lin linv])
                                           lin)
                                           (let ([lin (if (not (eq? linv lin))
                                                      (let ([lin (- 2)])
                                                      lin)
                                                      lin)])
                                           lin))])
                                (bb (+ x 1) col freecase lin))))))
                                (let ([win (if (>= col 0)
                                           (let ([win col])
                                           win)
                                           (let ([win (if (>= lin 0)
                                                      (let ([win lin])
                                                      win)
                                                      win)])
                                           win))])
                                (ba (+ y 1) freecase win))))])
                 (bb bc col freecase lin))))))
                 (let ([w 1])
                 (let ([z 2])
                 (letrec ([v (lambda (x win) 
                               (if (<= x z)
                               (let ([win (if (and (and (eq? (vector-ref (vector-ref (gamestate-cases g) 0) 0) x) (eq? (vector-ref (vector-ref (gamestate-cases g) 1) 1) x)) (eq? (vector-ref (vector-ref (gamestate-cases g) 2) 2) x))
                                          (let ([win x])
                                          win)
                                          win)])
                               (let ([win (if (and (and (eq? (vector-ref (vector-ref (gamestate-cases g) 0) 2) x) (eq? (vector-ref (vector-ref (gamestate-cases g) 1) 1) x)) (eq? (vector-ref (vector-ref (gamestate-cases g) 2) 0) x))
                                          (let ([win x])
                                          win)
                                          win)])
                               (v (+ x 1) win)))
                               (block
                                 (set-gamestate-ended! g (or (not (eq? win 0)) (eq? freecase 0)))
                                 (if (eq? win 1)
                                 (set-gamestate-note! g 1000)
                                 (block
                                   (if (eq? win 2)
                                   (set-gamestate-note! g (- 1000))
                                   (set-gamestate-note! g 0))
                                   '()
                                   ))
                                 '()
                                 )))])
                 (v w win))))))])
  (ba be freecase win))))))
)
(define (apply_move_xy x y g)
  ;toto
  (let ([player 2])
  (let ([player (if (gamestate-firstToPlay g)
                (let ([player 1])
                player)
                player)])
  (block
    (vector-set! (vector-ref (gamestate-cases g) x) y player)
    (set-gamestate-firstToPlay! g (not (gamestate-firstToPlay g)))
    )))
)
(define (apply_move m g)
  ;toto
  (block
    (apply_move_xy (move-x m) (move-y m) g)
    '()
    )
)
(define (cancel_move_xy x y g)
  ;toto
  (block
    (vector-set! (vector-ref (gamestate-cases g) x) y 0)
    (set-gamestate-firstToPlay! g (not (gamestate-firstToPlay g)))
    (set-gamestate-ended! g #f)
    )
)
(define (cancel_move m g)
  ;toto
  (block
    (cancel_move_xy (move-x m) (move-y m) g)
    '()
    )
)
(define (can_move_xy x y g)
  ;toto
  (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 0)
)
(define (can_move m g)
  ;toto
  (can_move_xy (move-x m) (move-y m) g)
)
(define (minmax g)
  ;toto
  (block
    (eval0 g)
    (if (gamestate-ended g)
    (gamestate-note g)
    (let ([maxNote (- 10000)])
    (let ([maxNote (if (not (gamestate-firstToPlay g))
                   (let ([maxNote 10000])
                   maxNote)
                   maxNote)])
    (let ([s 0])
    (let ([u 2])
    (letrec ([o (lambda (x maxNote) 
                  (if (<= x u)
                  (let ([q 0])
                  (let ([r 2])
                  (letrec ([p (lambda (y maxNote) 
                                (if (<= y r)
                                (let ([maxNote (if (can_move_xy x y g)
                                               (block
                                                 (apply_move_xy x y g)
                                                 (let ([currentNote (minmax g)])
                                                 (block
                                                   (cancel_move_xy x y g)
                                                   ; Minimum ou Maximum selon le cotÃ© ou l'on joue
                                                   (let ([maxNote (if (eq? (> currentNote maxNote) (gamestate-firstToPlay g))
                                                                  (let ([maxNote currentNote])
                                                                  maxNote)
                                                                  maxNote)])
                                                   maxNote)
                                                   ))
                                                 )
                                               maxNote)])
                                (p (+ y 1) maxNote))
                                (o (+ x 1) maxNote)))])
                  (p q maxNote))))
                  maxNote))])
    (o s maxNote)))))))
)
)
(define (play g)
  ;toto
  (let ([minMove (move 0 0)])
  (let ([minNote 10000])
  (let ([l 0])
  (let ([n 2])
  (letrec ([e (lambda (x minNote) 
                (if (<= x n)
                (let ([h 0])
                (let ([k 2])
                (letrec ([f (lambda (y minNote) 
                              (if (<= y k)
                              (let ([minNote (if (can_move_xy x y g)
                                             (block
                                               (apply_move_xy x y g)
                                               (let ([currentNote (minmax g)])
                                               (block
                                                 (map display (list x ", " y ", " currentNote "\n"))
                                                 (cancel_move_xy x y g)
                                                 (let ([minNote (if (< currentNote minNote)
                                                                (let ([minNote currentNote])
                                                                (block
                                                                  (set-move-x! minMove x)
                                                                  (set-move-y! minMove y)
                                                                  minNote
                                                                  ))
                                                                minNote)])
                                                 minNote)
                                                 ))
                                               )
                                             minNote)])
                              (f (+ y 1) minNote))
                              (e (+ x 1) minNote)))])
                (f h minNote))))
                (block
                  (map display (list (move-x minMove) (move-y minMove) "\n"))
                  minMove
                  )))])
  (e l minNote))))))
)
(define (init0 _)
  ;toto
  ((lambda (internal_env) (apply (lambda (b cases) 
                                        (block
                                          b
                                          (gamestate cases #f #t 0)
                                          )) internal_env)) (array_init_withenv 3 
  (lambda (i) 
    (lambda (_) ((lambda (internal_env) (apply (lambda (d tab) 
                                                      (block
                                                        d
                                                        (let ([a tab])
                                                        (list '() a))
                                                        )) internal_env)) (array_init_withenv 3 
    (lambda (j) 
      (lambda (_) (let ([c 0])
                  (list '() c)))) '())))) '()))
)
(define (read_move _)
  ;toto
  ((lambda (x) 
     (block
       (mread-blank)
       ((lambda (y) 
          (block
            (mread-blank)
            (move x y)
            )) (mread-int))
     )) (mread-int))
)
(define main
  (let ([bo 0])
  (let ([bp 1])
  (letrec ([bm (lambda (i) 
                 (if (<= i bp)
                 (let ([state (init0 'nil)])
                 (block
                   (apply_move (move 1 1) state)
                   (apply_move (move 0 0) state)
                   (letrec ([bn (lambda (_) 
                                  (if (not (gamestate-ended state))
                                  (block
                                    (print_state state)
                                    (apply_move (play state) state)
                                    (eval0 state)
                                    (print_state state)
                                    (if (not (gamestate-ended state))
                                    (block
                                      (apply_move (play state) state)
                                      (eval0 state)
                                      '()
                                      )
                                    '())
                                    (bn 'nil)
                                    )
                                  (block
                                    (print_state state)
                                    (map display (list (gamestate-note state) "\n"))
                                    (bm (+ i 1))
                                    )))])
                   (bn 'nil))
                 ))
                 '()))])
  (bm bo))))
)

