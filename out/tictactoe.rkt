#lang racket
(require racket/block)
(define last-char 0)
(define next-char (lambda () (set! last-char (read-char (current-input-port)))))
(next-char)
(define mread-int (lambda ()
  (if (eq? #\- last-char)
  (block
    (next-char) (- 0 (mread-int)))
    (letrec ([w (lambda (out)
      (if (eof-object? last-char)
        out
        (if (and last-char (>= (char->integer last-char) (char->integer #\0)) (<= (char->integer last-char) (char->integer #\9)))
          (let ([out (+ (* 10 out) (- (char->integer last-char) (char->integer #\0)))])
            (block
              (next-char)
              (w out)
          ))
        out
      )))]) (w 0)))))
(define mread-blank (lambda ()
  (if (or (eq? last-char #\NewLine) (eq? last-char #\Space) ) (block (next-char) (mread-blank)) '())
))

(struct gamestate ([cases #:mutable] [ended #:mutable] [firstToPlay #:mutable] [note #:mutable]))
(struct move ([x #:mutable] [y #:mutable]))
(define (print_state g)
  (block
    (display "\n|")
    (letrec ([p (lambda (y) 
                  (if (<= y 2)
                  (letrec ([q (lambda (x) 
                                (if (<= x 2)
                                (block
                                  (if (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 0)
                                  (display " ")
                                  (if (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 1)
                                  (display "O")
                                  (display "X")))
                                  (display "|")
                                  (q (+ x 1))
                                  )
                                (if (not (eq? y 2))
                                (block
                                  (display "\n|-|-|-|\n|")
                                  (p (+ y 1))
                                  )
                                (p (+ y 1)))))])
                  (q 0))
                  (display "\n")))])
  (p 0))
)
)
(define (eval0 g)
  (let ([win 0])
  (let ([freecase 0])
  (letrec ([n (lambda (y freecase win) 
                (if (<= y 2)
                (let ([col (- 1)])
                (let ([lin (- 1)])
                (letrec ([o (lambda (x col freecase lin) 
                              (if (<= x 2)
                              (let ([freecase (if (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 0)
                                              (let ([freecase (+ freecase 1)])
                                              freecase)
                                              freecase)])
                              (let ([colv (vector-ref (vector-ref (gamestate-cases g) x) y)])
                              (let ([linv (vector-ref (vector-ref (gamestate-cases g) y) x)])
                              (let ([col (if (and (eq? col (- 1)) (not (eq? colv 0)))
                                         (let ([col colv])
                                         col)
                                         (if (not (eq? colv col))
                                         (let ([col (- 2)])
                                         col)
                                         col))])
                              (if (and (eq? lin (- 1)) (not (eq? linv 0)))
                              (let ([lin linv])
                              (o (+ x 1) col freecase lin))
                              (if (not (eq? linv lin))
                              (let ([lin (- 2)])
                              (o (+ x 1) col freecase lin))
                              (o (+ x 1) col freecase lin)))))))
                              (if (>= col 0)
                              (let ([win col])
                              (n (+ y 1) freecase win))
                              (if (>= lin 0)
                              (let ([win lin])
                              (n (+ y 1) freecase win))
                              (n (+ y 1) freecase win)))))])
                (o 0 col freecase lin))))
                (letrec ([l (lambda (x win) 
                              (if (<= x 2)
                              (let ([win (if (and (and (eq? (vector-ref (vector-ref (gamestate-cases g) 0) 0) x) (eq? (vector-ref (vector-ref (gamestate-cases g) 1) 1) x)) (eq? (vector-ref (vector-ref (gamestate-cases g) 2) 2) x))
                                         (let ([win x])
                                         win)
                                         win)])
                              (if (and (and (eq? (vector-ref (vector-ref (gamestate-cases g) 0) 2) x) (eq? (vector-ref (vector-ref (gamestate-cases g) 1) 1) x)) (eq? (vector-ref (vector-ref (gamestate-cases g) 2) 0) x))
                              (let ([win x])
                              (l (+ x 1) win))
                              (l (+ x 1) win)))
                              (block
                                (set-gamestate-ended! g (or (not (eq? win 0)) (eq? freecase 0)))
                                (if (eq? win 1)
                                (set-gamestate-note! g 1000)
                                (if (eq? win 2)
                                (set-gamestate-note! g (- 1000))
                                (set-gamestate-note! g 0)))
                                )))])
                (l 1 win))))])
  (n 0 freecase win))))
)
(define (apply_move_xy x y g)
  (let ([player 2])
  (let ([player (if (gamestate-firstToPlay g)
                (let ([player 1])
                player)
                player)])
  (block
    (vector-set! (vector-ref (gamestate-cases g) x) y player)
    (set-gamestate-firstToPlay! g (not (gamestate-firstToPlay g)))
    )))
)
(define (apply_move m g)
  (block
    (apply_move_xy (move-x m) (move-y m) g)
    '()
    )
)
(define (cancel_move_xy x y g)
  (block
    (vector-set! (vector-ref (gamestate-cases g) x) y 0)
    (set-gamestate-firstToPlay! g (not (gamestate-firstToPlay g)))
    (set-gamestate-ended! g #f)
    )
)
(define (cancel_move m g)
  (block
    (cancel_move_xy (move-x m) (move-y m) g)
    '()
    )
)
(define (can_move_xy x y g)
  (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 0)
)
(define (can_move m g)
  (can_move_xy (move-x m) (move-y m) g)
)
(define (minmax g)
  (block
    (eval0 g)
    (if (gamestate-ended g)
    (gamestate-note g)
    (let ([maxNote (- 10000)])
    (let ([maxNote (if (not (gamestate-firstToPlay g))
                   (let ([maxNote 10000])
                   maxNote)
                   maxNote)])
    (letrec ([h (lambda (x maxNote) 
                  (if (<= x 2)
                  (letrec ([k (lambda (y maxNote) 
                                (if (<= y 2)
                                (if (can_move_xy x y g)
                                (block
                                  (apply_move_xy x y g)
                                  (let ([currentNote (minmax g)])
                                  (block
                                    (cancel_move_xy x y g)
                                    ; Minimum ou Maximum selon le cotÃ© ou l'on joue
                                    (if (eq? (> currentNote maxNote) (gamestate-firstToPlay g))
                                    (let ([maxNote currentNote])
                                    (k (+ y 1) maxNote))
                                    (k (+ y 1) maxNote))
                                    ))
                                  )
                                (k (+ y 1) maxNote))
                                (h (+ x 1) maxNote)))])
                  (k 0 maxNote))
                  maxNote))])
    (h 0 maxNote)))))
)
)
(define (play g)
  (let ([minMove (move 0 0)])
  (let ([minNote 10000])
  (letrec ([e (lambda (x minNote) 
                (if (<= x 2)
                (letrec ([f (lambda (y minNote) 
                              (if (<= y 2)
                              (if (can_move_xy x y g)
                              (block
                                (apply_move_xy x y g)
                                (let ([currentNote (minmax g)])
                                (block
                                  (printf "~a, ~a, ~a\n" x y currentNote)
                                  (cancel_move_xy x y g)
                                  (if (< currentNote minNote)
                                  (let ([minNote currentNote])
                                  (block
                                    (set-move-x! minMove x)
                                    (set-move-y! minMove y)
                                    (f (+ y 1) minNote)
                                    ))
                                  (f (+ y 1) minNote))
                                  ))
                                )
                              (f (+ y 1) minNote))
                              (e (+ x 1) minNote)))])
                (f 0 minNote))
                (block
                  (printf "~a~a\n" (move-x minMove) (move-y minMove))
                  minMove
                  )))])
  (e 0 minNote))))
)
(define (init0 _)
  (let ([cases (build-vector 3 (lambda (i) 
                                 (let ([tab (build-vector 3 (lambda (j) 
                                                              0))])
                                 tab)))])
(gamestate cases #f #t 0))
)
(define (read_move _)
  ((lambda (x) 
     (block
       (mread-blank)
       ((lambda (y) 
          (block
            (mread-blank)
            (move x y)
            )) (mread-int))
     )) (mread-int))
)
(define main
  (letrec ([r (lambda (i) 
                (if (<= i 1)
                (let ([state (init0 'nil)])
                (block
                  (apply_move (move 1 1) state)
                  (apply_move (move 0 0) state)
                  (letrec ([s (lambda (_) 
                                (if (not (gamestate-ended state))
                                (block
                                  (print_state state)
                                  (apply_move (play state) state)
                                  (eval0 state)
                                  (print_state state)
                                  (if (not (gamestate-ended state))
                                  (block
                                    (apply_move (play state) state)
                                    (eval0 state)
                                    (s 'nil)
                                    )
                                  (s 'nil))
                                  )
                                (block
                                  (print_state state)
                                  (printf "~a\n" (gamestate-note state))
                                  (r (+ i 1))
                                  )))])
                  (s 'nil))
                ))
                '()))])
(r 0))
)

