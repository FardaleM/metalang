#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))
(define last-char 0)
(define next-char (lambda () (set! last-char (read-char (current-input-port)))))
(next-char)
(define mread-int (lambda ()
  (if (eq? #\- last-char)
  (block
    (next-char) (- 0 (mread-int)))
    (letrec ([w (lambda (out)
      (if (eof-object? last-char)
        out
        (if (and last-char (>= (char->integer last-char) (char->integer #\0)) (<= (char->integer last-char) (char->integer #\9)))
          (let ([out (+ (* 10 out) (- (char->integer last-char) (char->integer #\0)))])
            (block
              (next-char)
              (w out)
          ))
        out
      )))]) (w 0)))))
(define mread-blank (lambda ()
  (if (or (eq? last-char #\NewLine) (eq? last-char #\Space) ) (block (next-char) (mread-blank)) '())
))

(struct gamestate ([cases #:mutable] [ended #:mutable] [firstToPlay #:mutable] [note #:mutable]))
(struct move ([x #:mutable] [y #:mutable]))
(define (print_state g)
  ;toto
  (block
    (display "\n|")
    (let ([bi 0])
    (let ([bj 2])
    (letrec ([be (lambda (y) 
                   (if (<= y bj)
                   (let ([bg 0])
                   (let ([bh 2])
                   (letrec ([bf (lambda (x) 
                                  (if (<= x bh)
                                  (block
                                    (if (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 0)
                                    (display " ")
                                    (block
                                      (if (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 1)
                                      (display "O")
                                      (display "X"))
                                      '()
                                      ))
                                    (display "|")
                                    (bf (+ x 1))
                                    )
                                  (block
                                    (if (not (eq? y 2))
                                    (display "\n|-|-|-|\n|")
                                    '())
                                    (be (+ y 1))
                                    )))])
                   (bf bg))))
                   (display "\n")))])
    (be bi))))
)
)
(define (eval_ g)
  ;toto
  (let ([win 0])
  (let ([freecase 0])
  (let ([bc 0])
  (let ([bd 2])
  (letrec ([w (lambda (y freecase win) 
                (if (<= y bd)
                (let ([col (- 1)])
                (let ([lin (- 1)])
                (let ([ba 0])
                (let ([bb 2])
                (letrec ([z (lambda (x col freecase lin) 
                              (if (<= x bb)
                              (let ([freecase (if (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 0)
                                              (let ([freecase (+ freecase 1)])
                                              freecase)
                                              freecase)])
                              (let ([colv (vector-ref (vector-ref (gamestate-cases g) x) y)])
                              (let ([linv (vector-ref (vector-ref (gamestate-cases g) y) x)])
                              (let ([col (if (and (eq? col (- 1)) (not (eq? colv 0)))
                                         (let ([col colv])
                                         col)
                                         (let ([col (if (not (eq? colv col))
                                                    (let ([col (- 2)])
                                                    col)
                                                    col)])
                                         col))])
                              (let ([lin (if (and (eq? lin (- 1)) (not (eq? linv 0)))
                                         (let ([lin linv])
                                         lin)
                                         (let ([lin (if (not (eq? linv lin))
                                                    (let ([lin (- 2)])
                                                    lin)
                                                    lin)])
                                         lin))])
                              (z (+ x 1) col freecase lin))))))
                              (let ([win (if (>= col 0)
                                         (let ([win col])
                                         win)
                                         (let ([win (if (>= lin 0)
                                                    (let ([win lin])
                                                    win)
                                                    win)])
                                         win))])
                              (w (+ y 1) freecase win))))])
                (z ba col freecase lin))))))
                (let ([u 1])
                (let ([v 2])
                (letrec ([s (lambda (x win) 
                              (if (<= x v)
                              (let ([win (if (and (and (eq? (vector-ref (vector-ref (gamestate-cases g) 0) 0) x) (eq? (vector-ref (vector-ref (gamestate-cases g) 1) 1) x)) (eq? (vector-ref (vector-ref (gamestate-cases g) 2) 2) x))
                                         (let ([win x])
                                         win)
                                         win)])
                              (let ([win (if (and (and (eq? (vector-ref (vector-ref (gamestate-cases g) 0) 2) x) (eq? (vector-ref (vector-ref (gamestate-cases g) 1) 1) x)) (eq? (vector-ref (vector-ref (gamestate-cases g) 2) 0) x))
                                         (let ([win x])
                                         win)
                                         win)])
                              (s (+ x 1) win)))
                              (block
                                (set-gamestate-ended! g (or (not (eq? win 0)) (eq? freecase 0)))
                                (if (eq? win 1)
                                (set-gamestate-note! g 1000)
                                (block
                                  (if (eq? win 2)
                                  (set-gamestate-note! g (- 1000))
                                  (set-gamestate-note! g 0))
                                  '()
                                  ))
                                '()
                                )))])
                (s u win))))))])
  (w bc freecase win))))))
)
(define (apply_move_xy x y g)
  ;toto
  (let ([player 2])
  (let ([player (if (gamestate-firstToPlay g)
                (let ([player 1])
                player)
                player)])
  (block
    (vector-set! (vector-ref (gamestate-cases g) x) y player)
    (set-gamestate-firstToPlay! g (not (gamestate-firstToPlay g)))
    )))
)
(define (apply_move m g)
  ;toto
  (block
    (apply_move_xy (move-x m) (move-y m) g)
    '()
    )
)
(define (cancel_move_xy x y g)
  ;toto
  (block
    (vector-set! (vector-ref (gamestate-cases g) x) y 0)
    (set-gamestate-firstToPlay! g (not (gamestate-firstToPlay g)))
    (set-gamestate-ended! g #f)
    )
)
(define (cancel_move m g)
  ;toto
  (block
    (cancel_move_xy (move-x m) (move-y m) g)
    '()
    )
)
(define (can_move_xy x y g)
  ;toto
  (eq? (vector-ref (vector-ref (gamestate-cases g) x) y) 0)
)
(define (can_move m g)
  ;toto
  (can_move_xy (move-x m) (move-y m) g)
)
(define (minmax g)
  ;toto
  (block
    (eval_ g)
    (if (gamestate-ended g)
    (gamestate-note g)
    (let ([maxNote (- 10000)])
    (let ([maxNote (if (not (gamestate-firstToPlay g))
                   (let ([maxNote 10000])
                   maxNote)
                   maxNote)])
    (let ([q 0])
    (let ([r 2])
    (letrec ([l (lambda (x maxNote) 
                  (if (<= x r)
                  (let ([o 0])
                  (let ([p 2])
                  (letrec ([n (lambda (y maxNote) 
                                (if (<= y p)
                                (let ([maxNote (if (can_move_xy x y g)
                                               (block
                                                 (apply_move_xy x y g)
                                                 (let ([currentNote (minmax g)])
                                                 (block
                                                   (cancel_move_xy x y g)
                                                   ; Minimum ou Maximum selon le cotÃ© ou l'on joue
                                                   (let ([maxNote (if (eq? (> currentNote maxNote) (gamestate-firstToPlay g))
                                                                  (let ([maxNote currentNote])
                                                                  maxNote)
                                                                  maxNote)])
                                                   maxNote)
                                                   ))
                                                 )
                                               maxNote)])
                                (n (+ y 1) maxNote))
                                (l (+ x 1) maxNote)))])
                  (n o maxNote))))
                  maxNote))])
    (l q maxNote)))))))
)
)
(define (play g)
  ;toto
  (let ([minMove (move 0 0)])
  (let ([minNote 10000])
  (let ([h 0])
  (let ([k 2])
  (letrec ([c (lambda (x minNote) 
                (if (<= x k)
                (let ([e 0])
                (let ([f 2])
                (letrec ([d (lambda (y minNote) 
                              (if (<= y f)
                              (let ([minNote (if (can_move_xy x y g)
                                             (block
                                               (apply_move_xy x y g)
                                               (let ([currentNote (minmax g)])
                                               (block
                                                 (map display (list x ", " y ", " currentNote "\n"))
                                                 (cancel_move_xy x y g)
                                                 (let ([minNote (if (< currentNote minNote)
                                                                (let ([minNote currentNote])
                                                                (block
                                                                  (set-move-x! minMove x)
                                                                  (set-move-y! minMove y)
                                                                  minNote
                                                                  ))
                                                                minNote)])
                                                 minNote)
                                                 ))
                                               )
                                             minNote)])
                              (d (+ y 1) minNote))
                              (c (+ x 1) minNote)))])
                (d e minNote))))
                (block
                  (map display (list (move-x minMove) (move-y minMove) "\n"))
                  minMove
                  )))])
  (c h minNote))))))
)
(define (init_ _)
  ;toto
  (let ([cases (array_init_withenv 3 (lambda (i) 
                                       (lambda (_) (let ([tab (array_init_withenv 3 
                                                   (lambda (j) 
                                                     (lambda (_) (let ([b 0])
                                                                 (list '() b)))) '())])
                                       (let ([a tab])
                                       (list '() a))))) '())])
(gamestate cases #f #t 0))
)
(define (read_move _)
  ;toto
  ((lambda (x) 
     (block
       (mread-blank)
       ((lambda (y) 
          (block
            (mread-blank)
            (move x y)
            )) (mread-int))
     )) (mread-int))
)
(define main
  (let ([bn 0])
  (let ([bo 1])
  (letrec ([bk (lambda (i) 
                 (if (<= i bo)
                 (let ([state (init_ 'nil)])
                 (block
                   (apply_move (move 1 1) state)
                   (apply_move (move 0 0) state)
                   (letrec ([bm (lambda (_) 
                                  (if (not (gamestate-ended state))
                                  (block
                                    (print_state state)
                                    (apply_move (play state) state)
                                    (eval_ state)
                                    (print_state state)
                                    (if (not (gamestate-ended state))
                                    (block
                                      (apply_move (play state) state)
                                      (eval_ state)
                                      '()
                                      )
                                    '())
                                    (bm 'nil)
                                    )
                                  (block
                                    (print_state state)
                                    (map display (list (gamestate-note state) "\n"))
                                    (bk (+ i 1))
                                    )))])
                   (bm 'nil))
                 ))
                 '()))])
  (bk bn))))
)

