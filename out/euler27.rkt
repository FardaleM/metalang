#lang racket
(require racket/block)

(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))
(define last-char 0)
(define next-char (lambda () (set! last-char (read-char (current-input-port)))))
(next-char)
(define mread-char (lambda ()
  (let ([ out last-char])
    (block
      (next-char)
      out
    ))))

(define mread-int (lambda ()
  (if (eq? #\- last-char)
  (block
    (next-char) (- 0 (mread-int)))
    (letrec ([w (lambda (out)
      (if (eof-object? last-char)
        out
        (if (and last-char (>= (char->integer last-char) (char->integer #\0)) (<= (char->integer last-char) (char->integer #\9)))
          (let ([out (+ (* 10 out) (- (char->integer last-char) (char->integer #\0)))])
            (block
              (next-char)
              (w out)
          ))
        out
      )))]) (w 0)))))

(define mread-blank (lambda ()
  (if (or (eq? last-char #\NewLine) (eq? last-char #\Space) ) (block (next-char) (mread-blank)) '())
))

(define eratostene (lambda (t_ max_) 
                     (let ([n 0])
                       (let ([v 2])
                         (let ([w (- max_ 1)])
                           (letrec ([q (lambda (i n t_ max_) 
                                         (if (<= i w)
                                           (let ([r (lambda (n t_ max_) 
                                                      (q (+ i 1) n t_ max_))])
                                           (if (eq? (vector-ref t_ i) i)
                                             (let ([n (+ n 1)])
                                               (let ([j (* i i)])
                                                 (letrec ([u (lambda (j n t_ max_) 
                                                               (if (and (< j max_) (> j 0))
                                                                 (block (vector-set! t_ j 0) 
                                                                 (let ([j (+ j i)])
                                                                   (u j n t_ max_)))
                                                                 (r n t_ max_)))])
                                                 (u j n t_ max_))))
                                           (r n t_ max_)))
                             n))])
                       (q v n t_ max_)))))))
(define isPrime (lambda (n primes len) 
                  (let ([i 0])
                    (let ([p (lambda (i n primes len) 
                               (letrec ([h (lambda (i n primes len) 
                                             (if (< (* (vector-ref primes i) (vector-ref primes i)) n)
                                               (let ([m (lambda (i n primes len) 
                                                          (let ([i (+ i 1)])
                                                            (h i n primes len)))])
                                               (if (eq? (remainder n (vector-ref primes i)) 0)
                                                 #f
                                                 (m i n primes len)))
                                             #t))])
                      (h i n primes len)))])
  (if (< n 0)
    (let ([n (- n)])
      (p i n primes len))
    (p i n primes len))))))
(define test (lambda (a b primes len) 
               (let ([e 0])
                 (let ([f 200])
                   (letrec ([c (lambda (n a b primes len) 
                                 (if (<= n f)
                                   (let ([j (+ (+ (* n n) (* a n)) b)])
                                     (let ([d (lambda (j a b primes len) 
                                                (c (+ n 1) a b primes len))])
                                     (if (not (isPrime j primes len))
                                       n
                                       (d j a b primes len))))
                                 200))])
                 (c e a b primes len))))))
(define main (let ([maximumprimes 1000])
               (let ([era (array_init_withenv maximumprimes (lambda (j) 
                                                              (lambda (maximumprimes) 
                                                                (let ([x j])
                                                                  (list maximumprimes x)))) maximumprimes)])
  (let ([result 0])
    (let ([max_ 0])
      (let ([nprimes (eratostene era maximumprimes)])
        (let ([primes (array_init_withenv nprimes (lambda (o) 
                                                    (lambda (internal_env) (apply (lambda
                                                     (nprimes max_ result maximumprimes) 
                                                    (let ([y 0])
                                                      (list (list nprimes max_ result maximumprimes) y))) internal_env))) (list nprimes max_ result maximumprimes))])
        (let ([l 0])
          (let ([bk 2])
            (let ([bl (- maximumprimes 1)])
              (letrec ([bi (lambda (k l nprimes max_ result maximumprimes) 
                             (if (<= k bl)
                               (let ([bj (lambda (l nprimes max_ result maximumprimes) 
                                           (bi (+ k 1) l nprimes max_ result maximumprimes))])
                               (if (eq? (vector-ref era k) k)
                                 (block (vector-set! primes l k) (let ([l (+ l 1)])
                                                                   (bj l nprimes max_ result maximumprimes)))
                                 (bj l nprimes max_ result maximumprimes)))
                             (block
                               (display l)
                               (display " == ")
                               (display nprimes)
                               (display "\n")
                               (let ([ma 0])
                                 (let ([mb 0])
                                   (let ([bg 3])
                                     (let ([bh 999])
                                       (letrec ([z (lambda (b mb ma l nprimes max_ result maximumprimes) 
                                                     (if (<= b bh)
                                                       (let ([ba (lambda (mb ma l nprimes max_ result maximumprimes) 
                                                                   (z (+ b 1) mb ma l nprimes max_ result maximumprimes))])
                                                       (if (eq? (vector-ref era b) b)
                                                         (let ([be (- 999)])
                                                           (let ([bf 999])
                                                             (letrec ([bb 
                                                               (lambda (a mb ma l nprimes max_ result maximumprimes) 
                                                                 (if (<= a bf)
                                                                   (let ([n1 (test a b primes nprimes)])
                                                                    (let ([n2 (test a (- b) primes nprimes)])
                                                                    (let ([bd 
                                                                    (lambda (n2 n1 mb ma l nprimes max_ result maximumprimes) 
                                                                    (let ([bc 
                                                                    (lambda (n2 n1 mb ma l nprimes max_ result maximumprimes) 
                                                                    (bb (+ a 1) mb ma l nprimes max_ result maximumprimes))])
                                                                    (if (> n2 max_)
                                                                    (let ([max_ n2])
                                                                    (let ([result (* (- a) b)])
                                                                    (let ([ma a])
                                                                    (let ([mb (- b)])
                                                                    (bc n2 n1 mb ma l nprimes max_ result maximumprimes)))))
                                                                    (bc n2 n1 mb ma l nprimes max_ result maximumprimes))))])
                                                                    (if (> n1 max_)
                                                                    (let ([max_ n1])
                                                                    (let ([result (* a b)])
                                                                    (let ([ma a])
                                                                    (let ([mb b])
                                                                    (bd n2 n1 mb ma l nprimes max_ result maximumprimes)))))
                                                                    (bd n2 n1 mb ma l nprimes max_ result maximumprimes)))))
                                                               (ba mb ma l nprimes max_ result maximumprimes)))])
                                                         (bb be mb ma l nprimes max_ result maximumprimes))))
                                         (ba mb ma l nprimes max_ result maximumprimes)))
                                     (block
                                       (display ma)
                                       (display " ")
                                       (display mb)
                                       (display "\n")
                                       (display max_)
                                       (display "\n")
                                       (display result)
                                       (display "\n")
                                       )))])
                               (z bg mb ma l nprimes max_ result maximumprimes))))))
          )))])
  (bi bk l nprimes max_ result maximumprimes))))))))))))

