#lang racket
(require racket/block)

(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))
(define last-char 0)
(define next-char (lambda () (set! last-char (read-char (current-input-port)))))
(next-char)
(define mread-char (lambda ()
  (let ([ out last-char])
    (block
      (next-char)
      out
    ))))

(define mread-int (lambda ()
  (if (eq? #\- last-char)
  (block
    (next-char) (- 0 (mread-int)))
    (letrec ([w (lambda (out)
      (if (eof-object? last-char)
        out
        (if (and last-char (>= (char->integer last-char) (char->integer #\0)) (<= (char->integer last-char) (char->integer #\9)))
          (let ([out (+ (* 10 out) (- (char->integer last-char) (char->integer #\0)))])
            (block
              (next-char)
              (w out)
          ))
        out
      )))]) (w 0)))))

(define mread-blank (lambda ()
  (if (or (eq? last-char #\NewLine) (eq? last-char #\Space) ) (block (next-char) (mread-blank)) '())
))

(define min2 (lambda (a b) 
               (let ([p (lambda (a b) 
                          '())])
               (if (< a b)
                 a
                 b))))
(define eratostene (lambda (t_ max_) 
                     (let ([n 0])
                       (let ([h 2])
                         (let ([m (- max_ 1)])
                           (letrec ([c (lambda (i n t_ max_) 
                                         (if (<= i m)
                                           (let ([d (lambda (n t_ max_) 
                                                      (c (+ i 1) n t_ max_))])
                                           (if (eq? (vector-ref t_ i) i)
                                             (let ([n (+ n 1)])
                                               (let ([j (* i i)])
                                                 (let ([e (lambda (j n t_ max_) 
                                                            (d n t_ max_))])
                                                 (if (eq? (quotient j i) i)
                                                   ; overflow test 
                                                   (letrec ([g (lambda (j n t_ max_) 
                                                                 (if (and (< j max_) (> j 0))
                                                                   (block (vector-set! t_ j 0) 
                                                                   (let ([j (+ j i)])
                                                                    (g j n t_ max_)))
                                                                   (e j n t_ max_)))])
                                                   (g j n t_ max_))
                                                 (e j n t_ max_)))))
                                         (d n t_ max_)))
                           n))])
                     (c h n t_ max_)))))))
(define main (let ([maximumprimes 1000001])
               (let ([era (array_init_withenv maximumprimes (lambda (j) 
                                                              (lambda (maximumprimes) 
                                                                (let ([q j])
                                                                  (list maximumprimes q)))) maximumprimes)])
  (let ([nprimes (eratostene era maximumprimes)])
    (let ([primes (array_init_withenv nprimes (lambda (o) 
                                                (lambda (internal_env) (apply (lambda
                                                 (nprimes maximumprimes) 
                                                (let ([r 0])
                                                  (list (list nprimes maximumprimes) r))) internal_env))) (list nprimes maximumprimes))])
    (let ([l 0])
      (let ([be 2])
        (let ([bf (- maximumprimes 1)])
          (letrec ([bc (lambda (k l nprimes maximumprimes) 
                         (if (<= k bf)
                           (let ([bd (lambda (l nprimes maximumprimes) 
                                       (bc (+ k 1) l nprimes maximumprimes))])
                           (if (eq? (vector-ref era k) k)
                             (block (vector-set! primes l k) (let ([l (+ l 1)])
                                                               (bd l nprimes maximumprimes)))
                             (bd l nprimes maximumprimes)))
                         (block
                           (display l)
                           (display " == ")
                           (display nprimes)
                           (display "\n")
                           (let ([sum (array_init_withenv nprimes (lambda (i_) 
                                                                    (lambda (internal_env) (apply (lambda
                                                                     (l nprimes maximumprimes) 
                                                                    (let ([s (vector-ref primes i_)])
                                                                    (list (list l nprimes maximumprimes) s))) internal_env))) (list l nprimes maximumprimes))])
                           (let ([maxl 0])
                             (let ([process #t])
                               (let ([stop (- maximumprimes 1)])
                                 (let ([len 1])
                                   (let ([resp 1])
                                     (letrec ([v (lambda (resp len stop process maxl l nprimes maximumprimes) 
                                                   (if process
                                                     (let ([process #f])
                                                       (let ([ba 0])
                                                         (let ([bb stop])
                                                           (letrec ([w 
                                                             (lambda (i resp len stop process maxl l nprimes maximumprimes) 
                                                               (if (<= i bb)
                                                                 (let ([x 
                                                                   (lambda (resp len stop process maxl l nprimes maximumprimes) 
                                                                    (w (+ i 1) resp len stop process maxl l nprimes maximumprimes))])
                                                                 (if (< (+ i len) nprimes)
                                                                   (block (vector-set! sum i (+ (vector-ref sum i) (vector-ref primes (+ i len)))) 
                                                                   (let ([y 
                                                                    (lambda (resp len stop process maxl l nprimes maximumprimes) 
                                                                    (x resp len stop process maxl l nprimes maximumprimes))])
                                                                   (if (> maximumprimes (vector-ref sum i))
                                                                    (let ([process #t])
                                                                    (let ([z 
                                                                    (lambda (resp len stop process maxl l nprimes maximumprimes) 
                                                                    (y resp len stop process maxl l nprimes maximumprimes))])
                                                                    (if (eq? (vector-ref era (vector-ref sum i)) (vector-ref sum i))
                                                                    (let ([maxl len])
                                                                    (let ([resp (vector-ref sum i)])
                                                                    (z resp len stop process maxl l nprimes maximumprimes)))
                                                                    (z resp len stop process maxl l nprimes maximumprimes))))
                                                                   (let ([stop (min2 stop i)])
                                                                    (y resp len stop process maxl l nprimes maximumprimes)))))
                                                               (x resp len stop process maxl l nprimes maximumprimes)))
                                                           (let ([len (+ len 1)])
                                                             (v resp len stop process maxl l nprimes maximumprimes))))])
                                                     (w ba resp len stop process maxl l nprimes maximumprimes)))))
                                   (block
                                     (display resp)
                                     (display "\n")
                                     (display maxl)
                                     (display "\n")
                                     )))])
                             (v resp len stop process maxl l nprimes maximumprimes))))))))
    )))])
(bc be l nprimes maximumprimes))))))))))

