#lang racket
(require racket/block)

(define (eratostene t0 max0)
  (let ([n 0])
  (letrec ([c (lambda (i n) (if (<= i (- max0 1))
                            (if (eq? (vector-ref t0 i) i)
                            (let ([n (+ n 1)])
                            (if (> (quotient max0 i) i)
                            (let ([j (* i i)])
                            (letrec ([d (lambda (j) (if (and (< j max0) (> j 0))
                                                    (block
                                                      (vector-set! t0 j 0)
                                                      (let ([j (+ j i)])
                                                      (d j))
                                                      )
                                                    (c (+ i 1) n)))])
                              (d j)))
                            (c (+ i 1) n)))
                            (c (+ i 1) n))
                            n))])
    (c 2 n)))
)
(define main
  (let ([maximumprimes 1000001])
  (let ([era (build-vector maximumprimes (lambda (j) 
                                           j))])
  (let ([nprimes (eratostene era maximumprimes)])
  (let ([primes (build-vector nprimes (lambda (o) 
                                        0))])
  (let ([l 0])
  (letrec ([e (lambda (k l) (if (<= k (- maximumprimes 1))
                            (if (eq? (vector-ref era k) k)
                            (block
                              (vector-set! primes l k)
                              (let ([l (+ l 1)])
                              (e (+ k 1) l))
                              )
                            (e (+ k 1) l))
                            (block
                              (printf "~a == ~a\n" l nprimes)
                              (let ([sum (build-vector nprimes (lambda (i_) 
                                                                 (vector-ref primes i_)))])
                              (let ([maxl 0])
                              (let ([process #t])
                              (let ([stop (- maximumprimes 1)])
                              (let ([len 1])
                              (let ([resp 1])
                              (letrec ([f (lambda (len maxl process resp stop) (if process
                                                                               (let ([process #f])
                                                                               (letrec ([g (lambda (i maxl process resp stop) 
                                                                                (if (<= i stop)
                                                                                (if (< (+ i len) nprimes)
                                                                                (block
                                                                                (vector-set! sum i (+ (vector-ref sum i) (vector-ref primes (+ i len))))
                                                                                (if (> maximumprimes (vector-ref sum i))
                                                                                (let ([process #t])
                                                                                (if (eq? (vector-ref era (vector-ref sum i)) (vector-ref sum i))
                                                                                (let ([maxl len])
                                                                                (let ([resp (vector-ref sum i)])
                                                                                (g (+ i 1) maxl process resp stop)))
                                                                                (g (+ i 1) maxl process resp stop)))
                                                                                (let ([stop (min stop i)])
                                                                                (g (+ i 1) maxl process resp stop)))
                                                                                )
                                                                                (g (+ i 1) maxl process resp stop))
                                                                                (let ([len (+ len 1)])
                                                                                (f len maxl process resp stop))))])
                                                                                (g 0 maxl process resp stop)))
                                                                               (printf "~a\n~a\n" resp maxl)))])
                                (f len maxl process resp stop))))))))
                            )))])
  (e 2 l)))))))
)

