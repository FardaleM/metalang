#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))

(define (eratostene t0 max0)
  ;toto
  (let ([n 0])
  (let ([g 2])
  (let ([h (- max0 1)])
  (letrec ([d (lambda (i n) 
                (if (<= i h)
                (let ([n (if (eq? (vector-ref t0 i) i)
                         (let ([n (+ n 1)])
                         (block
                           (if (> (quotient max0 i) i)
                           (let ([j (* i i)])
                           (letrec ([f (lambda (j) 
                                         (if (and (< j max0) (> j 0))
                                         (block
                                           (vector-set! t0 j 0)
                                           (let ([j (+ j i)])
                                           (f j))
                                           )
                                         '()))])
                           (f j)))
                           '())
                         n
                         ))
                n)])
                (d (+ i 1) n))
                n))])
  (d g n)))))
)
(define main
  (let ([maximumprimes 1000001])
  (let ([era (array_init_withenv maximumprimes (lambda (j) 
                                                 (lambda (_) (let ([m j])
                                                             (list '() m)))) '())])
  (let ([nprimes (eratostene era maximumprimes)])
  (let ([primes (array_init_withenv nprimes (lambda (o) 
                                              (lambda (_) (let ([p 0])
                                                          (list '() p)))) '())])
  (let ([l 0])
  (let ([y 2])
  (let ([z (- maximumprimes 1)])
  (letrec ([x (lambda (k l) 
                (if (<= k z)
                (let ([l (if (eq? (vector-ref era k) k)
                         (block
                           (vector-set! primes l k)
                           (let ([l (+ l 1)])
                           l)
                           )
                         l)])
                (x (+ k 1) l))
                (block
                  (map display (list l " == " nprimes "\n"))
                  (let ([sum (array_init_withenv nprimes (lambda (i_) 
                                                           (lambda (_) 
                                                           (let ([q (vector-ref primes i_)])
                                                           (list '() q)))) '())])
                  (let ([maxl 0])
                  (let ([process #t])
                  (let ([stop (- maximumprimes 1)])
                  (let ([len 1])
                  (let ([resp 1])
                  (letrec ([s (lambda (len maxl process resp stop) 
                                (if process
                                (let ([process #f])
                                (let ([v 0])
                                (let ([w stop])
                                (letrec ([u (lambda (i maxl process resp stop) 
                                              (if (<= i w)
                                              ((lambda (internal_env) (apply (lambda
                                               (maxl process resp stop) 
                                              (u (+ i 1) maxl process resp stop)) internal_env)) 
                                              (if (< (+ i len) nprimes)
                                              (block
                                                (vector-set! sum i (+ (vector-ref sum i) (vector-ref primes (+ i len))))
                                                ((lambda (internal_env) (apply (lambda
                                                 (maxl process resp stop) 
                                                (list maxl process resp stop)) internal_env)) 
                                                (if (> maximumprimes (vector-ref sum i))
                                                (let ([process #t])
                                                ((lambda (internal_env) (apply (lambda
                                                 (maxl resp) 
                                                (list maxl process resp stop)) internal_env)) 
                                                (if (eq? (vector-ref era (vector-ref sum i)) (vector-ref sum i))
                                                (let ([maxl len])
                                                (let ([resp (vector-ref sum i)])
                                                (list maxl resp)))
                                                (list maxl resp))))
                                                (let ([stop (min stop i)])
                                                (list maxl process resp stop))))
                                                )
                                              (list maxl process resp stop)))
                                              (let ([len (+ len 1)])
                                              (s len maxl process resp stop))))])
                                (u v maxl process resp stop)))))
                                (block
                                  (map display (list resp "\n" maxl "\n"))
                                  )))])
                  (s len maxl process resp stop))))))))
    )))])
  (x y l)))))))))
)

