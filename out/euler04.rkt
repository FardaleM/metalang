#lang racket
(require racket/block)

(define (chiffre c m)
  ;toto
  (let ([g (lambda (_) 
             '())])
  (if (eq? c 0)
  (remainder m 10)
  (chiffre (- c 1) (quotient m 10))))
)
(define main
  (let ([m 1])
  (let ([z 0])
  (let ([ba 9])
  (letrec ([h (lambda (a m) 
                (if (<= a ba)
                (let ([x 1])
                (let ([y 9])
                (letrec ([i (lambda (f m) 
                              (if (<= f y)
                              (let ([v 0])
                              (let ([w 9])
                              (letrec ([j (lambda (d m) 
                                            (if (<= d w)
                                            (let ([s 1])
                                            (let ([u 9])
                                            (letrec ([k (lambda (c m) 
                                                          (if (<= c u)
                                                          (let ([q 0])
                                                          (let ([r 9])
                                                          (letrec ([l (lambda (b m) 
                                                                        (if (<= b r)
                                                                        (let ([o 0])
                                                                        (let ([p 9])
                                                                        (letrec ([n 
                                                                          (lambda (e m) 
                                                                            (if (<= e p)
                                                                            (let ([mul (+ (+ (+ (+ (* a d) (* 10 (+ (* a e) (* b d)))) (* 100 (+ (+ (* a f) (* b e)) (* c d)))) (* 1000 (+ (* c e) (* b f)))) (* (* 10000 c) f))])
                                                                            (let ([m 
                                                                            (if (and (and (eq? (chiffre 0 mul) (chiffre 5 mul)) (eq? (chiffre 1 mul) (chiffre 4 mul))) (eq? (chiffre 2 mul) (chiffre 3 mul)))
                                                                            (let ([m (max mul m)])
                                                                            m)
                                                                            m)])
                                                                            (n (+ e 1) m)))
                                                                            (l (+ b 1) m)))])
                                                                        (n o m))))
                                                                        (k (+ c 1) m)))])
                                                          (l q m))))
                                              (j (+ d 1) m)))])
                                            (k s m))))
                              (i (+ f 1) m)))])
                              (j v m))))
                (h (+ a 1) m)))])
    (i x m))))
  (block
    (map display (list m "\n"))
    )))])
(h z m)))))
)

