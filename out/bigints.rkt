#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (let ((tab (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    ))))) (list env tab))))
(define last-char 0)
(define next-char (lambda () (set! last-char (read-char (current-input-port)))))
(next-char)
(define mread-char (lambda ()
  (let ([ out last-char])
    (block
      (next-char)
      out
    ))))
(define mread-blank (lambda ()
  (if (or (eq? last-char #\NewLine) (eq? last-char #\Space) ) (block (next-char) (mread-blank)) '())
))

(struct bigint ([bigint_chiffres #:mutable] [bigint_len #:mutable] [bigint_sign #:mutable]))

(define (read_bigint len)
  (let ([chiffres (build-vector len (lambda (j) 
                                      ((lambda (c) 
                                         (char->integer c)) (mread-char))))])
(let ([e (quotient (- len 1) 2)])
(letrec ([f (lambda (i) (if (<= i e)
                        (let ([tmp (vector-ref chiffres i)])
                        (block
                          (vector-set! chiffres i (vector-ref chiffres (- (- len 1) i)))
                          (vector-set! chiffres (- (- len 1) i) tmp)
                          (f (+ i 1))
                          ))
                        (bigint chiffres len #t)))])
  (f 0))))
)

(define (print_bigint a)
  (block
    (if (not (bigint-bigint_sign a))
    (display (integer->char 45))
    '())
    (let ([g (- (bigint-bigint_len a) 1)])
    (letrec ([h (lambda (i) (if (<= i g)
                            (block
                              (display (vector-ref (bigint-bigint_chiffres a) (- (- (bigint-bigint_len a) 1) i)))
                              (h (+ i 1))
                              )
                            '()))])
      (h 0)))
    )
)

(define (bigint_eq a b)
  ; Renvoie vrai si a = b 
  (if (not (eq? (bigint-bigint_sign a) (bigint-bigint_sign b)))
  #f
  (if (not (eq? (bigint-bigint_len a) (bigint-bigint_len b)))
  #f
  (let ([m (- (bigint-bigint_len a) 1)])
  (letrec ([o (lambda (i) (if (<= i m)
                          (if (not (eq? (vector-ref (bigint-bigint_chiffres a) i) (vector-ref (bigint-bigint_chiffres b) i)))
                          #f
                          (o (+ i 1)))
                          #t))])
    (o 0)))))
)

(define (bigint_gt a b)
  ; Renvoie vrai si a > b 
  (if (and (bigint-bigint_sign a) (not (bigint-bigint_sign b)))
  #t
  (if (and (not (bigint-bigint_sign a)) (bigint-bigint_sign b))
  #f
  (if (> (bigint-bigint_len a) (bigint-bigint_len b))
  (bigint-bigint_sign a)
  (if (< (bigint-bigint_len a) (bigint-bigint_len b))
  (not (bigint-bigint_sign a))
  (let ([p (- (bigint-bigint_len a) 1)])
  (letrec ([q (lambda (i) (if (<= i p)
                          (let ([j (- (- (bigint-bigint_len a) 1) i)])
                          (if (> (vector-ref (bigint-bigint_chiffres a) j) (vector-ref (bigint-bigint_chiffres b) j))
                          (bigint-bigint_sign a)
                          (if (< (vector-ref (bigint-bigint_chiffres a) j) (vector-ref (bigint-bigint_chiffres b) j))
                          (not (bigint-bigint_sign a))
                          (q (+ i 1)))))
                          #t))])
    (q 0)))))))
)

(define (bigint_lt a b)
  (not (bigint_gt a b))
)

(define (add_bigint_positif a b)
  ; Une addition ou on en a rien a faire des signes 
  (let ([len (+ (max (bigint-bigint_len a) (bigint-bigint_len b)) 1)])
  (let ([retenue 0])
  ((lambda (internal_env) (apply (lambda (retenue chiffres) 
                                        (letrec ([s (lambda (len) (if (and (> len 0) (eq? (vector-ref chiffres (- len 1)) 0))
                                                                  (let ([len (- len 1)])
                                                                  (s len))
                                                                  (bigint chiffres len #t)))])
                                          (s len))) internal_env)) (array_init_withenv len 
  (lambda (i) 
    (lambda (retenue) 
      (let ([tmp retenue])
      (let ([tmp (if (< i (bigint-bigint_len a))
                 (+ tmp (vector-ref (bigint-bigint_chiffres a) i))
                 tmp)])
      (let ([tmp (if (< i (bigint-bigint_len b))
                 (+ tmp (vector-ref (bigint-bigint_chiffres b) i))
                 tmp)])
      (let ([retenue (quotient tmp 10)])
      (let ([r (remainder tmp 10)])
      (list retenue r)))))))) retenue))))
)

(define (sub_bigint_positif a b)
  ; Une soustraction ou on en a rien a faire des signes
  ;Pré-requis : a > b
  ;
  (let ([len (bigint-bigint_len a)])
  (let ([retenue 0])
  ((lambda (internal_env) (apply (lambda (retenue chiffres) 
                                        (letrec ([v (lambda (len) (if (and (> len 0) (eq? (vector-ref chiffres (- len 1)) 0))
                                                                  (let ([len (- len 1)])
                                                                  (v len))
                                                                  (bigint chiffres len #t)))])
                                          (v len))) internal_env)) (array_init_withenv len 
  (lambda (i) 
    (lambda (retenue) 
      (let ([tmp (+ retenue (vector-ref (bigint-bigint_chiffres a) i))])
      (let ([tmp (if (< i (bigint-bigint_len b))
                 (- tmp (vector-ref (bigint-bigint_chiffres b) i))
                 tmp)])
      ((lambda (internal_env) (apply (lambda (retenue tmp) 
                                            (let ([u tmp])
                                            (list retenue u))) internal_env)) (if (< tmp 0)
                                                                              (let ([tmp (+ tmp 10)])
                                                                              (let ([retenue (- 1)])
                                                                              (list retenue tmp)))
                                                                              (let ([retenue 0])
                                                                              (list retenue tmp)))))))) retenue))))
)

(define (neg_bigint a)
  (bigint (bigint-bigint_chiffres a) (bigint-bigint_len a) (not (bigint-bigint_sign a)))
)

(define (add_bigint a b)
  (if (eq? (bigint-bigint_sign a) (bigint-bigint_sign b))
  (if (bigint-bigint_sign a)
  (add_bigint_positif a b)
  (neg_bigint (add_bigint_positif a b)))
  (if (bigint-bigint_sign a)
  ; a positif, b negatif 
  (if (bigint_gt a (neg_bigint b))
  (sub_bigint_positif a b)
  (neg_bigint (sub_bigint_positif b a)))
  ; a negatif, b positif 
  (if (bigint_gt (neg_bigint a) b)
  (neg_bigint (sub_bigint_positif a b))
  (sub_bigint_positif b a))))
)

(define (sub_bigint a b)
  (add_bigint a (neg_bigint b))
)

(define (mul_bigint_cp a b)
  ; Cet algorithm est quadratique.
  ;C'est le même que celui qu'on enseigne aux enfants en CP.
  ;D'ou le nom de la fonction. 
  (let ([len (+ (bigint-bigint_len a) (bigint-bigint_len b) 1)])
  (let ([chiffres (build-vector len (lambda (k) 
                                      0))])
  (let ([w (- (bigint-bigint_len a) 1)])
  (letrec ([x (lambda (i) (if (<= i w)
                          (let ([retenue 0])
                          (let ([z (- (bigint-bigint_len b) 1)])
                          (letrec ([ba (lambda (j retenue) (if (<= j z)
                                                           (block
                                                             (vector-set! chiffres (+ i j) (+ (vector-ref chiffres (+ i j)) retenue (* (vector-ref (bigint-bigint_chiffres b) j) (vector-ref (bigint-bigint_chiffres a) i))))
                                                             (let ([retenue (quotient (vector-ref chiffres (+ i j)) 10)])
                                                             (block
                                                               (vector-set! chiffres (+ i j) (remainder (vector-ref chiffres (+ i j)) 10))
                                                               (ba (+ j 1) retenue)
                                                               ))
                                                             )
                                                           (block
                                                             (vector-set! chiffres (+ i (bigint-bigint_len b)) (+ (vector-ref chiffres (+ i (bigint-bigint_len b))) retenue))
                                                             (x (+ i 1))
                                                             )))])
                            (ba 0 retenue))))
                          (block
                            (vector-set! chiffres (+ (bigint-bigint_len a) (bigint-bigint_len b)) (quotient (vector-ref chiffres (- (+ (bigint-bigint_len a) (bigint-bigint_len b)) 1)) 10))
                            (vector-set! chiffres (- (+ (bigint-bigint_len a) (bigint-bigint_len b)) 1) (remainder (vector-ref chiffres (- (+ (bigint-bigint_len a) (bigint-bigint_len b)) 1)) 10))
                            (letrec ([y (lambda (l len) (if (<= l 2)
                                                        (if (and (not (eq? len 0)) (eq? (vector-ref chiffres (- len 1)) 0))
                                                        (let ([len (- len 1)])
                                                        (y (+ l 1) len))
                                                        (y (+ l 1) len))
                                                        (bigint chiffres len (eq? (bigint-bigint_sign a) (bigint-bigint_sign b)))))])
                              (y 0 len))
                            )))])
    (x 0)))))
)

(define (bigint_premiers_chiffres a i)
  (let ([len (min i (bigint-bigint_len a))])
  (letrec ([bc (lambda (len) (if (and (not (eq? len 0)) (eq? (vector-ref (bigint-bigint_chiffres a) (- len 1)) 0))
                             (let ([len (- len 1)])
                             (bc len))
                             (bigint (bigint-bigint_chiffres a) len (bigint-bigint_sign a))))])
    (bc len)))
)

(define (bigint_shift a i)
  (let ([chiffres (build-vector (+ (bigint-bigint_len a) i) (lambda (k) 
                                                              (if (>= k i)
                                                              (vector-ref (bigint-bigint_chiffres a) (- k i))
                                                              0)))])
  (bigint chiffres (+ (bigint-bigint_len a) i) (bigint-bigint_sign a)))
)

(define (mul_bigint aa bb)
  (if (eq? (bigint-bigint_len aa) 0)
  aa
  (if (eq? (bigint-bigint_len bb) 0)
  bb
  (if (or (< (bigint-bigint_len aa) 3) (< (bigint-bigint_len bb) 3))
  (mul_bigint_cp aa bb)
  ; Algorithme de Karatsuba 
  (let ([split (quotient (min (bigint-bigint_len aa) (bigint-bigint_len bb)) 2)])
  (let ([a (bigint_shift aa (- split))])
  (let ([b (bigint_premiers_chiffres aa split)])
  (let ([c (bigint_shift bb (- split))])
  (let ([d (bigint_premiers_chiffres bb split)])
  (let ([amoinsb (sub_bigint a b)])
  (let ([cmoinsd (sub_bigint c d)])
  (let ([ac (mul_bigint a c)])
  (let ([bd (mul_bigint b d)])
  (let ([amoinsbcmoinsd (mul_bigint amoinsb cmoinsd)])
  (let ([acdec (bigint_shift ac (* 2 split))])
  (add_bigint (add_bigint acdec bd) (bigint_shift (sub_bigint (add_bigint ac bd) amoinsbcmoinsd) split))))))))))))))))
)

(define (log10 a)
  (let ([out0 1])
  (letrec ([be (lambda (a out0) (if (>= a 10)
                                (let ([a (quotient a 10)])
                                (let ([out0 (+ out0 1)])
                                (be a out0)))
                                out0))])
    (be a out0)))
)

(define (bigint_of_int i)
  (let ([size (log10 i)])
  (let ([size (if (eq? i 0)
              0
              size)])
  (let ([t0 (build-vector size (lambda (j) 
                                 0))])
  (letrec ([bf (lambda (k i) (if (<= k (- size 1))
                             (block
                               (vector-set! t0 k (remainder i 10))
                               (let ([i (quotient i 10)])
                               (bf (+ k 1) i))
                               )
                             (bigint t0 size #t)))])
    (bf 0 i)))))
)

(define (fact_bigint a)
  (let ([one (bigint_of_int 1)])
  (let ([out0 one])
  (letrec ([bg (lambda (a out0) (if (not (bigint_eq a one))
                                (let ([out0 (mul_bigint a out0)])
                                (let ([a (sub_bigint a one)])
                                (bg a out0)))
                                out0))])
    (bg a out0))))
)

(define (sum_chiffres_bigint a)
  (let ([out0 0])
  (let ([bh (- (bigint-bigint_len a) 1)])
  (letrec ([bi (lambda (i out0) (if (<= i bh)
                                (let ([out0 (+ out0 (vector-ref (bigint-bigint_chiffres a) i))])
                                (bi (+ i 1) out0))
                                out0))])
    (bi 0 out0))))
)

(define (euler20 _)
  (let ([a (bigint_of_int 15)])
  ; normalement c'est 100 
  (let ([a (fact_bigint a)])
  (sum_chiffres_bigint a)))
)

(define (bigint_exp a b)
  (if (eq? b 1)
  a
  (if (eq? (remainder b 2) 0)
  (bigint_exp (mul_bigint a a) (quotient b 2))
  (mul_bigint a (bigint_exp a (- b 1)))))
)

(define (bigint_exp_10chiffres a b)
  (let ([a (bigint_premiers_chiffres a 10)])
  (if (eq? b 1)
  a
  (if (eq? (remainder b 2) 0)
  (bigint_exp_10chiffres (mul_bigint a a) (quotient b 2))
  (mul_bigint a (bigint_exp_10chiffres a (- b 1))))))
)

(define (euler48 _)
  (let ([sum (bigint_of_int 0)])
  (letrec ([bj (lambda (i sum) (if (<= i 100)
                               ; 1000 normalement 
                               (let ([ib (bigint_of_int i)])
                               (let ([ibeib (bigint_exp_10chiffres ib i)])
                               (let ([sum (add_bigint sum ibeib)])
                               (let ([sum (bigint_premiers_chiffres sum 10)])
                               (bj (+ i 1) sum)))))
                               (block
                                 (display "euler 48 = ")
                                 (print_bigint sum)
                                 (display "\n")
                                 )))])
    (bj 1 sum)))
)

(define (euler16 _)
  (let ([a (bigint_of_int 2)])
  (let ([a (bigint_exp a 100)])
  ; 1000 normalement 
  (sum_chiffres_bigint a)))
)

(define (euler25 _)
  (let ([i 2])
  (let ([a (bigint_of_int 1)])
  (let ([b (bigint_of_int 1)])
  (letrec ([bk (lambda (a b i) (if (< (bigint-bigint_len b) 100)
                               ; 1000 normalement 
                               (let ([c (add_bigint a b)])
                               (let ([a b])
                               (let ([b c])
                               (let ([i (+ i 1)])
                               (bk a b i)))))
                               i))])
    (bk a b i)))))
)

(define (euler29 _)
  (let ([maxA 5])
  (let ([maxB 5])
  (let ([a_bigint (build-vector (+ maxA 1) (lambda (j) 
                                             (bigint_of_int (* j j))))])
  (let ([a0_bigint (build-vector (+ maxA 1) (lambda (j2) 
                                              (bigint_of_int j2)))])
  (let ([b (build-vector (+ maxA 1) (lambda (k) 
                                      2))])
  (let ([n 0])
  (let ([found #t])
  (letrec ([bl (lambda (found n) (if found
                                 (let ([min0 (vector-ref a0_bigint 0)])
                                 (let ([found #f])
                                 (letrec ([bm (lambda (i found min0) (if (<= i maxA)
                                                                     (if (<= (vector-ref b i) maxB)
                                                                     (if found
                                                                     (if (bigint_lt (vector-ref a_bigint i) min0)
                                                                     (let ([min0 (vector-ref a_bigint i)])
                                                                     (bm (+ i 1) found min0))
                                                                     (bm (+ i 1) found min0))
                                                                     (let ([min0 (vector-ref a_bigint i)])
                                                                     (let ([found #t])
                                                                     (bm (+ i 1) found min0))))
                                                                     (bm (+ i 1) found min0))
                                                                     (if found
                                                                     (let ([n (+ n 1)])
                                                                     (letrec ([bn (lambda (l) 
                                                                       (if (<= l maxA)
                                                                       (if (and (bigint_eq (vector-ref a_bigint l) min0) (<= (vector-ref b l) maxB))
                                                                       (block
                                                                         (vector-set! b l (+ (vector-ref b l) 1))
                                                                         (vector-set! a_bigint l (mul_bigint (vector-ref a_bigint l) (vector-ref a0_bigint l)))
                                                                         (bn (+ l 1))
                                                                         )
                                                                       (bn (+ l 1)))
                                                                       (bl found n)))])
                                                                       (bn 2)))
                                                                     (bl found n))))])
                                   (bm 2 found min0))))
                                 n))])
    (bl found n)))))))))
)

(define main
  (block
    (printf "~a\n" (euler29 'nil))
    (let ([sum (read_bigint 50)])
    (letrec ([bo (lambda (i sum) (if (<= i 100)
                                 (block
                                   (mread-blank)
                                   (let ([tmp (read_bigint 50)])
                                   (let ([sum (add_bigint sum tmp)])
                                   (bo (+ i 1) sum)))
                                   )
                                 (block
                                   (display "euler13 = ")
                                   (print_bigint sum)
                                   (printf "\neuler25 = ~a\neuler16 = ~a\n" (euler25 'nil) (euler16 'nil))
                                   (euler48 'nil)
                                   (printf "euler20 = ~a\n" (euler20 'nil))
                                   (let ([a (bigint_of_int 999999)])
                                   (let ([b (bigint_of_int 9951263)])
                                   (block
                                     (print_bigint a)
                                     (display ">>1=")
                                     (print_bigint (bigint_shift a (- 1)))
                                     (display "\n")
                                     (print_bigint a)
                                     (display "*")
                                     (print_bigint b)
                                     (display "=")
                                     (print_bigint (mul_bigint a b))
                                     (display "\n")
                                     (print_bigint a)
                                     (display "*")
                                     (print_bigint b)
                                     (display "=")
                                     (print_bigint (mul_bigint_cp a b))
                                     (display "\n")
                                     (print_bigint a)
                                     (display "+")
                                     (print_bigint b)
                                     (display "=")
                                     (print_bigint (add_bigint a b))
                                     (display "\n")
                                     (print_bigint b)
                                     (display "-")
                                     (print_bigint a)
                                     (display "=")
                                     (print_bigint (sub_bigint b a))
                                     (display "\n")
                                     (print_bigint a)
                                     (display "-")
                                     (print_bigint b)
                                     (display "=")
                                     (print_bigint (sub_bigint a b))
                                     (display "\n")
                                     (print_bigint a)
                                     (display ">")
                                     (print_bigint b)
                                     (display "=")
                                     (if (bigint_gt a b)
                                     (display "True")
                                     (display "False"))
                                     (display "\n")
                                     )))
                                   )))])
      (bo 2 sum)))
    )
)

