#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (let ((tab (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    ))))) (list env tab))))
(define last-char 0)
(define next-char (lambda () (set! last-char (read-char (current-input-port)))))
(next-char)
(define mread-char (lambda ()
  (let ([ out last-char])
    (block
      (next-char)
      out
    ))))
(define mread-blank (lambda ()
  (if (or (eq? last-char #\NewLine) (eq? last-char #\Space) ) (block (next-char) (mread-blank)) '())
))

(struct bigint ([bigint_chiffres #:mutable] [bigint_len #:mutable] [bigint_sign #:mutable]))
(define (read_bigint len)
  ;toto
  ((lambda (internal_env) (apply (lambda (dl chiffres) 
                                        (block
                                          dl
                                          (let ([dn 0])
                                          (let ([dp (quotient (- len 1) 2)])
                                          (letrec ([dm (lambda (i) 
                                                         (if (<= i dp)
                                                         (let ([tmp (vector-ref chiffres i)])
                                                         (block
                                                           (vector-set! chiffres i (vector-ref chiffres (- (- len 1) i)))
                                                           (vector-set! chiffres (- (- len 1) i) tmp)
                                                           (dm (+ i 1))
                                                           ))
                                                         (bigint chiffres len #t)))])
                                          (dm dn))))
                                        )) internal_env)) (array_init_withenv len 
(lambda (j) 
  (lambda (_) ((lambda (c) 
                 (let ([dk (char->integer c)])
                 (list '() dk))) (mread-char)))) '()))
)
(define (print_bigint a)
  ;toto
  (block
    (if (not (bigint-bigint_sign a))
    (display (integer->char 45))
    '())
    (let ([di 0])
    (let ([dj (- (bigint-bigint_len a) 1)])
    (letrec ([dh (lambda (i) 
                   (if (<= i dj)
                   (block
                     (display (vector-ref (bigint-bigint_chiffres a) (- (- (bigint-bigint_len a) 1) i)))
                     (dh (+ i 1))
                     )
                   '()))])
    (dh di))))
  )
)
(define (bigint_eq a b)
  ;toto
  ; Renvoie vrai si a = b 
  (let ([dc (lambda (_) 
              '())])
  (if (not (eq? (bigint-bigint_sign a) (bigint-bigint_sign b)))
  #f
  (let ([dd (lambda (_) 
              (dc 'nil))])
  (if (not (eq? (bigint-bigint_len a) (bigint-bigint_len b)))
  #f
  (let ([df 0])
  (let ([dg (- (bigint-bigint_len a) 1)])
  (letrec ([de (lambda (i) 
                 (if (<= i dg)
                 (if (not (eq? (vector-ref (bigint-bigint_chiffres a) i) (vector-ref (bigint-bigint_chiffres b) i)))
                 #f
                 (de (+ i 1)))
                 #t))])
  (de df))))))))
)
(define (bigint_gt a b)
  ;toto
  ; Renvoie vrai si a > b 
  (let ([cu (lambda (_) 
              '())])
  (if (and (bigint-bigint_sign a) (not (bigint-bigint_sign b)))
  #t
  (let ([cv (lambda (_) 
              (cu 'nil))])
  (if (and (not (bigint-bigint_sign a)) (bigint-bigint_sign b))
  #f
  (let ([cw (lambda (_) 
              #t)])
  (if (> (bigint-bigint_len a) (bigint-bigint_len b))
  (bigint-bigint_sign a)
  (let ([cx (lambda (_) 
              (cw 'nil))])
  (if (< (bigint-bigint_len a) (bigint-bigint_len b))
  (not (bigint-bigint_sign a))
  (let ([da 0])
  (let ([db (- (bigint-bigint_len a) 1)])
  (letrec ([cy (lambda (i) 
                 (if (<= i db)
                 (let ([j (- (- (bigint-bigint_len a) 1) i)])
                 (let ([cz (lambda (_) 
                             (cy (+ i 1)))])
                 (if (> (vector-ref (bigint-bigint_chiffres a) j) (vector-ref (bigint-bigint_chiffres b) j))
                 (bigint-bigint_sign a)
                 (if (< (vector-ref (bigint-bigint_chiffres a) j) (vector-ref (bigint-bigint_chiffres b) j))
                 (not (bigint-bigint_sign a))
                 (cz 'nil)))))
                 (cx 'nil)))])
  (cy da))))))))))))
)
(define (bigint_lt a b)
  ;toto
  (not (bigint_gt a b))
)
(define (add_bigint_positif a b)
  ;toto
  ; Une addition ou on en a rien a faire des signes 
  (let ([len (+ (max (bigint-bigint_len a) (bigint-bigint_len b)) 1)])
  (let ([retenue 0])
  ((lambda (internal_env) (apply (lambda (cs chiffres) 
                                        (let ([retenue cs])
                                        (letrec ([ct (lambda (len) 
                                                       (if (and (> len 0) (eq? (vector-ref chiffres (- len 1)) 0))
                                                       (let ([len (- len 1)])
                                                       (ct len))
                                                       (bigint chiffres len #t)))])
                                        (ct len)))) internal_env)) (array_init_withenv len 
  (lambda (i) 
    (lambda (retenue) 
      (let ([tmp retenue])
      (let ([tmp (if (< i (bigint-bigint_len a))
                 (let ([tmp (+ tmp (vector-ref (bigint-bigint_chiffres a) i))])
                 tmp)
                 tmp)])
      (let ([tmp (if (< i (bigint-bigint_len b))
                 (let ([tmp (+ tmp (vector-ref (bigint-bigint_chiffres b) i))])
                 tmp)
                 tmp)])
      (let ([retenue (quotient tmp 10)])
      (let ([cr (remainder tmp 10)])
      (list retenue cr)))))))) retenue))))
)
(define (sub_bigint_positif a b)
  ;toto
  ; Une soustraction ou on en a rien a faire des signes
  ;Pré-requis : a > b
  ;
  (let ([len (bigint-bigint_len a)])
  (let ([retenue 0])
  ((lambda (internal_env) (apply (lambda (cp chiffres) 
                                        (let ([retenue cp])
                                        (letrec ([cq (lambda (len) 
                                                       (if (and (> len 0) (eq? (vector-ref chiffres (- len 1)) 0))
                                                       (let ([len (- len 1)])
                                                       (cq len))
                                                       (bigint chiffres len #t)))])
                                        (cq len)))) internal_env)) (array_init_withenv len 
  (lambda (i) 
    (lambda (retenue) 
      (let ([tmp (+ retenue (vector-ref (bigint-bigint_chiffres a) i))])
      (let ([tmp (if (< i (bigint-bigint_len b))
                 (let ([tmp (- tmp (vector-ref (bigint-bigint_chiffres b) i))])
                 tmp)
                 tmp)])
      ((lambda (internal_env) (apply (lambda (retenue tmp) 
                                            (let ([co tmp])
                                            (list retenue co))) internal_env)) 
      (if (< tmp 0)
      (let ([tmp (+ tmp 10)])
      (let ([retenue (- 1)])
      (list retenue tmp)))
      (let ([retenue 0])
      (list retenue tmp)))))))) retenue))))
)
(define (neg_bigint a)
  ;toto
  (bigint (bigint-bigint_chiffres a) (bigint-bigint_len a) (not (bigint-bigint_sign a)))
)
(define (add_bigint a b)
  ;toto
  (let ([cj (lambda (_) 
              '())])
  (if (eq? (bigint-bigint_sign a) (bigint-bigint_sign b))
  (let ([ck (lambda (_) 
              (cj 'nil))])
  (if (bigint-bigint_sign a)
  (add_bigint_positif a b)
  (neg_bigint (add_bigint_positif a b))))
  (let ([cl (lambda (_) 
              (cj 'nil))])
  (if (bigint-bigint_sign a)
  ; a positif, b negatif 
  (let ([cm (lambda (_) 
              (cl 'nil))])
  (if (bigint_gt a (neg_bigint b))
  (sub_bigint_positif a b)
  (neg_bigint (sub_bigint_positif b a))))
  ; a negatif, b positif 
  (let ([cn (lambda (_) 
              (cl 'nil))])
  (if (bigint_gt (neg_bigint a) b)
  (neg_bigint (sub_bigint_positif a b))
  (sub_bigint_positif b a)))))))
)
(define (sub_bigint a b)
  ;toto
  (add_bigint a (neg_bigint b))
)
(define (mul_bigint_cp a b)
  ;toto
  ; Cet algorithm est quadratique.
  ;C'est le même que celui qu'on enseigne aux enfants en CP.
  ;D'ou le nom de la fonction. 
  (let ([len (+ (+ (bigint-bigint_len a) (bigint-bigint_len b)) 1)])
  ((lambda (internal_env) (apply (lambda (bz chiffres) 
                                        (block
                                          bz
                                          (let ([ch 0])
                                          (let ([ci (- (bigint-bigint_len a) 1)])
                                          (letrec ([cd (lambda (i) 
                                                         (if (<= i ci)
                                                         (let ([retenue 0])
                                                         (let ([cf 0])
                                                         (let ([cg (- (bigint-bigint_len b) 1)])
                                                         (letrec ([ce 
                                                           (lambda (j retenue) 
                                                             (if (<= j cg)
                                                             (block
                                                               (vector-set! chiffres (+ i j) (+ (vector-ref chiffres (+ i j)) (+ retenue (* (vector-ref (bigint-bigint_chiffres b) j) (vector-ref (bigint-bigint_chiffres a) i)))))
                                                               (let ([retenue (quotient (vector-ref chiffres (+ i j)) 10)])
                                                               (block
                                                                 (vector-set! chiffres (+ i j) (remainder (vector-ref chiffres (+ i j)) 10))
                                                                 (ce (+ j 1) retenue)
                                                                 ))
                                                               )
                                                             (block
                                                               (vector-set! chiffres (+ i (bigint-bigint_len b)) (+ (vector-ref chiffres (+ i (bigint-bigint_len b))) retenue))
                                                               (cd (+ i 1))
                                                               )))])
                                                         (ce cf retenue)))))
                                                         (block
                                                           (vector-set! chiffres (+ (bigint-bigint_len a) (bigint-bigint_len b)) (quotient (vector-ref chiffres (- (+ (bigint-bigint_len a) (bigint-bigint_len b)) 1)) 10))
                                                           (vector-set! chiffres (- (+ (bigint-bigint_len a) (bigint-bigint_len b)) 1) (remainder (vector-ref chiffres (- (+ (bigint-bigint_len a) (bigint-bigint_len b)) 1)) 10))
                                                           (let ([cb 0])
                                                           (let ([cc 2])
                                                           (letrec ([ca 
                                                             (lambda (l len) 
                                                               (if (<= l cc)
                                                               (let ([len 
                                                               (if (and (not (eq? len 0)) (eq? (vector-ref chiffres (- len 1)) 0))
                                                               (let ([len (- len 1)])
                                                               len)
                                                               len)])
                                                               (ca (+ l 1) len))
                                                               (bigint chiffres len (eq? (bigint-bigint_sign a) (bigint-bigint_sign b)))))])
                                                           (ca cb len))))
                                                         )))])
                                          (cd ch))))
  )) internal_env)) (array_init_withenv len (lambda (k) 
                                              (lambda (_) (let ([by 0])
                                                          (list '() by)))) '())))
)
(define (bigint_premiers_chiffres a i)
  ;toto
  (let ([len (min i (bigint-bigint_len a))])
  (letrec ([bx (lambda (len) 
                 (if (and (not (eq? len 0)) (eq? (vector-ref (bigint-bigint_chiffres a) (- len 1)) 0))
                 (let ([len (- len 1)])
                 (bx len))
                 (bigint (bigint-bigint_chiffres a) len (bigint-bigint_sign a))))])
  (bx len)))
)
(define (bigint_shift a i)
  ;toto
  ((lambda (internal_env) (apply (lambda (bv chiffres) 
                                        (block
                                          bv
                                          (bigint chiffres (+ (bigint-bigint_len a) i) (bigint-bigint_sign a))
                                          )) internal_env)) (array_init_withenv (+ (bigint-bigint_len a) i) 
  (lambda (k) 
    (lambda (_) (let ([bw (lambda (_) 
                            (lambda (bu) 
                              (list '() bu)))])
  (if (>= k i)
  (let ([bu (vector-ref (bigint-bigint_chiffres a) (- k i))])
  (list '() bu))
  (let ([bu 0])
  (list '() bu)))))) '()))
)
(define (mul_bigint aa bb)
  ;toto
  (let ([bs (lambda (_) 
              ; Algorithme de Karatsuba 
              (let ([split (quotient (min (bigint-bigint_len aa) (bigint-bigint_len bb)) 2)])
              (let ([a (bigint_shift aa (- split))])
              (let ([b (bigint_premiers_chiffres aa split)])
              (let ([c (bigint_shift bb (- split))])
              (let ([d (bigint_premiers_chiffres bb split)])
              (let ([amoinsb (sub_bigint a b)])
              (let ([cmoinsd (sub_bigint c d)])
              (let ([ac (mul_bigint a c)])
              (let ([bd (mul_bigint b d)])
              (let ([amoinsbcmoinsd (mul_bigint amoinsb cmoinsd)])
              (let ([acdec (bigint_shift ac (* 2 split))])
              (add_bigint (add_bigint acdec bd) (bigint_shift (sub_bigint (add_bigint ac bd) amoinsbcmoinsd) split))))))))))))))])
  (if (eq? (bigint-bigint_len aa) 0)
  aa
  (let ([bt (lambda (_) 
              (bs 'nil))])
  (if (eq? (bigint-bigint_len bb) 0)
  bb
  (if (or (< (bigint-bigint_len aa) 3) (< (bigint-bigint_len bb) 3))
  (mul_bigint_cp aa bb)
  (bt 'nil))))))
)
(define (log10 a)
  ;toto
  (let ([out0 1])
  (letrec ([br (lambda (a out0) 
                 (if (>= a 10)
                 (let ([a (quotient a 10)])
                 (let ([out0 (+ out0 1)])
                 (br a out0)))
                 out0))])
  (br a out0)))
)
(define (bigint_of_int i)
  ;toto
  (let ([size (log10 i)])
  (let ([size (if (eq? i 0)
              (let ([size 0])
              size)
              size)])
  ((lambda (internal_env) (apply (lambda (bn t0) 
                                        (block
                                          bn
                                          (let ([bp 0])
                                          (let ([bq (- size 1)])
                                          (letrec ([bo (lambda (k i) 
                                                         (if (<= k bq)
                                                         (block
                                                           (vector-set! t0 k (remainder i 10))
                                                           (let ([i (quotient i 10)])
                                                           (bo (+ k 1) i))
                                                           )
                                                         (bigint t0 size #t)))])
                                          (bo bp i))))
                                        )) internal_env)) (array_init_withenv size 
  (lambda (j) 
    (lambda (_) (let ([bm 0])
                (list '() bm)))) '()))))
)
(define (fact_bigint a)
  ;toto
  (let ([one (bigint_of_int 1)])
  (let ([out0 one])
  (letrec ([bl (lambda (a out0) 
                 (if (not (bigint_eq a one))
                 (let ([out0 (mul_bigint a out0)])
                 (let ([a (sub_bigint a one)])
                 (bl a out0)))
                 out0))])
  (bl a out0))))
)
(define (sum_chiffres_bigint a)
  ;toto
  (let ([out0 0])
  (let ([bj 0])
  (let ([bk (- (bigint-bigint_len a) 1)])
  (letrec ([bi (lambda (i out0) 
                 (if (<= i bk)
                 (let ([out0 (+ out0 (vector-ref (bigint-bigint_chiffres a) i))])
                 (bi (+ i 1) out0))
                 out0))])
  (bi bj out0)))))
)
(define (euler20 _)
  ;toto
  (let ([a (bigint_of_int 15)])
  ; normalement c'est 100 
  (let ([a (fact_bigint a)])
  (sum_chiffres_bigint a)))
)
(define (bigint_exp a b)
  ;toto
  (let ([bg (lambda (_) 
              '())])
  (if (eq? b 1)
  a
  (let ([bh (lambda (_) 
              (bg 'nil))])
  (if (eq? (remainder b 2) 0)
  (bigint_exp (mul_bigint a a) (quotient b 2))
  (mul_bigint a (bigint_exp a (- b 1)))))))
)
(define (bigint_exp_10chiffres a b)
  ;toto
  (let ([a (bigint_premiers_chiffres a 10)])
  (let ([be (lambda (_) 
              '())])
  (if (eq? b 1)
  a
  (let ([bf (lambda (_) 
              (be 'nil))])
  (if (eq? (remainder b 2) 0)
  (bigint_exp_10chiffres (mul_bigint a a) (quotient b 2))
  (mul_bigint a (bigint_exp_10chiffres a (- b 1))))))))
)
(define (euler48 _)
  ;toto
  (let ([sum (bigint_of_int 0)])
  (let ([ba 1])
  (let ([bc 100])
  (letrec ([z (lambda (i sum) 
                (if (<= i bc)
                ; 1000 normalement 
                (let ([ib (bigint_of_int i)])
                (let ([ibeib (bigint_exp_10chiffres ib i)])
                (let ([sum (add_bigint sum ibeib)])
                (let ([sum (bigint_premiers_chiffres sum 10)])
                (z (+ i 1) sum)))))
                (block
                  (display "euler 48 = ")
                  (print_bigint sum)
                  (display "\n")
                  )))])
  (z ba sum)))))
)
(define (euler16 _)
  ;toto
  (let ([a (bigint_of_int 2)])
  (let ([a (bigint_exp a 100)])
  ; 1000 normalement 
  (sum_chiffres_bigint a)))
)
(define (euler25 _)
  ;toto
  (let ([i 2])
  (let ([a (bigint_of_int 1)])
  (let ([b (bigint_of_int 1)])
  (letrec ([y (lambda (a b i) 
                (if (< (bigint-bigint_len b) 100)
                ; 1000 normalement 
                (let ([c (add_bigint a b)])
                (let ([a b])
                (let ([b c])
                (let ([i (+ i 1)])
                (y a b i)))))
                i))])
  (y a b i)))))
)
(define (euler29 _)
  ;toto
  (let ([maxA 5])
  (let ([maxB 5])
  ((lambda (internal_env) (apply (lambda (g a_bigint) 
                                        (block
                                          g
                                          ((lambda (internal_env) (apply (lambda
                                           (m a0_bigint) 
                                          (block
                                            m
                                            ((lambda (internal_env) (apply (lambda
                                             (p b) 
                                            (block
                                              p
                                              (let ([n 0])
                                              (let ([found #t])
                                              (letrec ([q (lambda (found n) 
                                                            (if found
                                                            (let ([min0 (vector-ref a0_bigint 0)])
                                                            (let ([found #f])
                                                            (let ([w 2])
                                                            (let ([x maxA])
                                                            (letrec ([v 
                                                              (lambda (i found min0) 
                                                                (if (<= i x)
                                                                ((lambda (internal_env) (apply (lambda
                                                                 (found min0) 
                                                                (v (+ i 1) found min0)) internal_env)) 
                                                                (if (<= (vector-ref b i) maxB)
                                                                ((lambda (internal_env) (apply (lambda
                                                                 (found min0) 
                                                                (list found min0)) internal_env)) 
                                                                (if found
                                                                (let ([min0 
                                                                (if (bigint_lt (vector-ref a_bigint i) min0)
                                                                (let ([min0 (vector-ref a_bigint i)])
                                                                min0)
                                                                min0)])
                                                                (list found min0))
                                                                (let ([min0 (vector-ref a_bigint i)])
                                                                (let ([found #t])
                                                                (list found min0)))))
                                                                (list found min0)))
                                                                (let ([n 
                                                                (if found
                                                                (let ([n (+ n 1)])
                                                                (let ([s 2])
                                                                (let ([u maxA])
                                                                (letrec ([r 
                                                                  (lambda (l) 
                                                                    (if (<= l u)
                                                                    (block
                                                                    (if (and (bigint_eq (vector-ref a_bigint l) min0) (<= (vector-ref b l) maxB))
                                                                    (block
                                                                    (vector-set! b l (+ (vector-ref b l) 1))
                                                                    (vector-set! a_bigint l (mul_bigint (vector-ref a_bigint l) (vector-ref a0_bigint l)))
                                                                    )
                                                                    '())
                                                                    (r (+ l 1))
                                                                    )
                                                                    n))])
                                                                (r s)))))
                                                                n)])
                                                                (q found n))))])
                                                            (v w found min0))))))
                                                n))])
                                              (q found n))))
                                          )) internal_env)) (array_init_withenv (+ maxA 1) 
                                        (lambda (k) 
                                          (lambda (_) (let ([o 2])
                                                      (list '() o)))) '()))
  )) internal_env)) (array_init_withenv (+ maxA 1) (lambda (j2) 
                                                     (lambda (_) (let ([h (bigint_of_int j2)])
                                                                 (list '() h)))) '()))
)) internal_env)) (array_init_withenv (+ maxA 1) (lambda (j) 
                                                   (lambda (_) (let ([f (bigint_of_int (* j j))])
                                                               (list '() f)))) '()))))
)
(define main
  (block
    (map display (list (euler29 'nil) "\n"))
    (let ([sum (read_bigint 50)])
    (let ([dr 2])
    (let ([ds 100])
    (letrec ([dq (lambda (i sum) 
                   (if (<= i ds)
                   (block
                     (mread-blank)
                     (let ([tmp (read_bigint 50)])
                     (let ([sum (add_bigint sum tmp)])
                     (dq (+ i 1) sum)))
                     )
                   (block
                     (display "euler13 = ")
                     (print_bigint sum)
                     (map display (list "\n" "euler25 = " (euler25 'nil) "\n" "euler16 = " (euler16 'nil) "\n"))
                     (euler48 'nil)
                     (map display (list "euler20 = " (euler20 'nil) "\n"))
                     (let ([a (bigint_of_int 999999)])
                     (let ([b (bigint_of_int 9951263)])
                     (block
                       (print_bigint a)
                       (display ">>1=")
                       (print_bigint (bigint_shift a (- 1)))
                       (display "\n")
                       (print_bigint a)
                       (display "*")
                       (print_bigint b)
                       (display "=")
                       (print_bigint (mul_bigint a b))
                       (display "\n")
                       (print_bigint a)
                       (display "*")
                       (print_bigint b)
                       (display "=")
                       (print_bigint (mul_bigint_cp a b))
                       (display "\n")
                       (print_bigint a)
                       (display "+")
                       (print_bigint b)
                       (display "=")
                       (print_bigint (add_bigint a b))
                       (display "\n")
                       (print_bigint b)
                       (display "-")
                       (print_bigint a)
                       (display "=")
                       (print_bigint (sub_bigint b a))
                       (display "\n")
                       (print_bigint a)
                       (display "-")
                       (print_bigint b)
                       (display "=")
                       (print_bigint (sub_bigint a b))
                       (display "\n")
                       (print_bigint a)
                       (display ">")
                       (print_bigint b)
                       (display "=")
                       (let ([e (bigint_gt a b)])
                       (block
                         (if e
                         (display "True")
                         (display "False"))
                         (display "\n")
                         ))
                       )))
                     )))])
    (dq dr sum)))))
  )
)

