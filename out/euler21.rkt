#lang racket
(require racket/block)

(define (eratostene t0 max0)
  ;toto
  (let ([n 0])
  (letrec ([m (lambda (i n) 
                (if (<= i (- max0 1))
                (if (eq? (vector-ref t0 i) i)
                (let ([n (+ n 1)])
                (let ([j (* i i)])
                (letrec ([q (lambda (j) 
                              (if (and (< j max0) (> j 0))
                              (block
                                (vector-set! t0 j 0)
                                (let ([j (+ j i)])
                                (q j))
                                )
                              (m (+ i 1) n)))])
                (q j))))
                (m (+ i 1) n))
                n))])
  (m 2 n)))
)
(define (fillPrimesFactors t0 n primes nprimes)
  ;toto
  (letrec ([g (lambda (i n) 
                (if (<= i (- nprimes 1))
                (let ([d (vector-ref primes i)])
                (letrec ([h (lambda (n) 
                              (if (eq? (remainder n d) 0)
                              (block
                                (vector-set! t0 d (+ (vector-ref t0 d) 1))
                                (let ([n (quotient n d)])
                                (h n))
                                )
                              (if (eq? n 1)
                              (vector-ref primes i)
                              (g (+ i 1) n))))])
                (h n)))
                n))])
(g 0 n))
)
(define (sumdivaux2 t0 n i)
  ;toto
  (letrec ([f (lambda (i) 
                (if (and (< i n) (eq? (vector-ref t0 i) 0))
                (let ([i (+ i 1)])
                (f i))
                i))])
  (f i))
)
(define (sumdivaux t0 n i)
  ;toto
  (if (> i n)
  1
  (if (eq? (vector-ref t0 i) 0)
  (sumdivaux t0 n (sumdivaux2 t0 n (+ i 1)))
  (let ([o (sumdivaux t0 n (sumdivaux2 t0 n (+ i 1)))])
  (let ([out0 0])
  (let ([p i])
  (let ([e (vector-ref t0 i)])
  (letrec ([c (lambda (j out0 p) 
                (if (<= j e)
                (let ([out0 (+ out0 p)])
                (let ([p (* p i)])
                (c (+ j 1) out0 p)))
                (* (+ out0 1) o)))])
  (c 1 out0 p))))))))
)
(define (sumdiv nprimes primes n)
  ;toto
  (let ([t0 (build-vector (+ n 1) (lambda (i) 
                                    0))])
  (let ([max0 (fillPrimesFactors t0 n primes nprimes)])
  (sumdivaux t0 max0 0)))
)
(define main
  (let ([maximumprimes 1001])
  (let ([era (build-vector maximumprimes (lambda (j) 
                                           j))])
  (let ([nprimes (eratostene era maximumprimes)])
  (let ([primes (build-vector nprimes (lambda (o) 
                                        0))])
  (let ([l 0])
  (letrec ([x (lambda (k l) 
                (if (<= k (- maximumprimes 1))
                (if (eq? (vector-ref era k) k)
                (block
                  (vector-set! primes l k)
                  (let ([l (+ l 1)])
                  (x (+ k 1) l))
                  )
                (x (+ k 1) l))
                (block
                  (printf "~a == ~a\n" l nprimes)
                  (let ([sum 0])
                  (letrec ([w (lambda (n sum) 
                                (if (<= n 1000)
                                (let ([other (- (sumdiv nprimes primes n) n)])
                                (if (> other n)
                                (let ([othersum (- (sumdiv nprimes primes other) other)])
                                (if (eq? othersum n)
                                (block
                                  (printf "~a & ~a\n" other n)
                                  (let ([sum (+ sum (+ other n))])
                                  (w (+ n 1) sum))
                                  )
                                (w (+ n 1) sum)))
                                (w (+ n 1) sum)))
                                (printf "\n~a\n" sum)))])
                  (w 2 sum)))
                )))])
  (x 2 l)))))))
)

