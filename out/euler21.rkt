#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))

(define eratostene (lambda (t_ max_) 
                     (let ([n 0])
                       (let ([ba 2])
                         (let ([bb (- max_ 1)])
                           (letrec ([x (lambda (i n) 
                                         (if (<= i bb)
                                           (let ([n (if (eq? (vector-ref t_ i) i)
                                                      (let ([n (+ n 1)])
                                                        (let ([j (* i i)])
                                                          (letrec ([z 
                                                            (lambda (j) 
                                                              (if (and (< j max_) (> j 0))
                                                                (block
                                                                  (vector-set! t_ j 0)
                                                                  (let ([j (+ j i)])
                                                                    (z j))
                                                                  )
                                                                n))])
                                                          (z j))))
                                             n)])
                                           (x (+ i 1) n))
                                         n))])
                         (x ba n)))))))
(define fillPrimesFactors (lambda (t_ n primes nprimes) 
                            (let ([v 0])
                              (let ([w (- nprimes 1)])
                                (letrec ([r (lambda (i n) 
                                              (if (<= i w)
                                                (let ([d (vector-ref primes i)])
                                                  (letrec ([u (lambda (n) 
                                                                (if (eq? (remainder n d) 0)
                                                                  (block
                                                                    (vector-set! t_ d (+ (vector-ref t_ d) 1))
                                                                    (let ([n (quotient n d)])
                                                                    (u n))
                                                                    )
                                                                  (if (eq? n 1)
                                                                    (vector-ref primes i)
                                                                    (r (+ i 1) n))))])
                                                  (u n)))
                                              n))])
                              (r v n))))))
(define sumdivaux2 (lambda (t_ n i) 
                     (letrec ([q (lambda (i) 
                                   (if (and (< i n) (eq? (vector-ref t_ i) 0))
                                     (let ([i (+ i 1)])
                                       (q i))
                                     i))])
                     (q i))))
(define sumdivaux (lambda (t_ n i) 
                    (let ([c (lambda (_) 
                               '())])
                    (if (> i n)
                      1
                      (let ([e (lambda (_) 
                                 (c 'nil))])
                      (if (eq? (vector-ref t_ i) 0)
                        (sumdivaux t_ n (sumdivaux2 t_ n (+ i 1)))
                        (let ([o (sumdivaux t_ n (sumdivaux2 t_ n (+ i 1)))])
                          (let ([out_ 0])
                            (let ([p i])
                              (let ([g 1])
                                (let ([h (vector-ref t_ i)])
                                  (letrec ([f (lambda (j out_ p) 
                                                (if (<= j h)
                                                  (let ([out_ (+ out_ p)])
                                                    (let ([p (* p i)])
                                                      (f (+ j 1) out_ p)))
                                                  (* (+ out_ 1) o)))])
                                  (f g out_ p)))))))))))))
(define sumdiv (lambda (nprimes primes n) 
                 (let ([a (+ n 1)])
                   (let ([t_ (array_init_withenv a (lambda (i) 
                                                     (lambda (_) (let ([b 0])
                                                                   (list '() b)))) '())])
                   (let ([max_ (fillPrimesFactors t_ n primes nprimes)])
                     (sumdivaux t_ max_ 0))))))
(define main (let ([maximumprimes 1001])
               (let ([era (array_init_withenv maximumprimes (lambda (j) 
                                                              (lambda (_) 
                                                              (let ([bc j])
                                                                (list '() bc)))) '())])
               (let ([nprimes (eratostene era maximumprimes)])
                 (let ([primes (array_init_withenv nprimes (lambda (o) 
                                                             (lambda (_) 
                                                             (let ([bd 0])
                                                               (list '() bd)))) '())])
                 (let ([l 0])
                   (let ([bi 2])
                     (let ([bj (- maximumprimes 1)])
                       (letrec ([bh (lambda (k l) 
                                      (if (<= k bj)
                                        (let ([l (if (eq? (vector-ref era k) k)
                                                   (block
                                                     (vector-set! primes l k)
                                                     (let ([l (+ l 1)])
                                                       l)
                                                     )
                                                   l)])
                                          (bh (+ k 1) l))
                                        (block
                                          (display l)
                                          (display " == ")
                                          (display nprimes)
                                          (display "\n")
                                          (let ([sum 0])
                                            (let ([bf 2])
                                              (let ([bg 1000])
                                                (letrec ([be (lambda (n sum) 
                                                               (if (<= n bg)
                                                                 (let ([other (- (sumdiv nprimes primes n) n)])
                                                                   (let ([sum 
                                                                    (if (> other n)
                                                                    (let ([othersum (- (sumdiv nprimes primes other) other)])
                                                                    (let ([sum 
                                                                    (if (eq? othersum n)
                                                                    (block
                                                                    (display other)
                                                                    (display " & ")
                                                                    (display n)
                                                                    (display "\n")
                                                                    (let ([sum (+ sum (+ other n))])
                                                                    sum)
                                                                    )
                                                                    sum)])
                                                                    sum))
                                                                    sum)])
                                                                    (be (+ n 1) sum)))
                                                                 (block
                                                                   (display "\n")
                                                                   (display sum)
                                                                   (display "\n")
                                                                   )))])
                                                (be bf sum)))))
                                        )))])
                     (bh bi l))))))))))

