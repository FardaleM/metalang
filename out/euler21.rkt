#lang racket
(require racket/block)
(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))

(define (eratostene t0 max0)
  ;toto
  (let ([n 0])
  (let ([w 2])
  (let ([x (- max0 1)])
  (letrec ([u (lambda (i n) 
                (if (<= i x)
                (let ([n (if (eq? (vector-ref t0 i) i)
                         (let ([n (+ n 1)])
                         (let ([j (* i i)])
                         (letrec ([v (lambda (j) 
                                       (if (and (< j max0) (> j 0))
                                       (block
                                         (vector-set! t0 j 0)
                                         (let ([j (+ j i)])
                                         (v j))
                                         )
                                       n))])
                         (v j))))
                n)])
                (u (+ i 1) n))
                n))])
  (u w n)))))
)
(define (fillPrimesFactors t0 n primes nprimes)
  ;toto
  (let ([r 0])
  (let ([s (- nprimes 1)])
  (letrec ([m (lambda (i n) 
                (if (<= i s)
                (let ([d (vector-ref primes i)])
                (letrec ([q (lambda (n) 
                              (if (eq? (remainder n d) 0)
                              (block
                                (vector-set! t0 d (+ (vector-ref t0 d) 1))
                                (let ([n (quotient n d)])
                                (q n))
                                )
                              (if (eq? n 1)
                              (vector-ref primes i)
                              (m (+ i 1) n))))])
                (q n)))
                n))])
  (m r n))))
)
(define (sumdivaux2 t0 n i)
  ;toto
  (letrec ([h (lambda (i) 
                (if (and (< i n) (eq? (vector-ref t0 i) 0))
                (let ([i (+ i 1)])
                (h i))
                i))])
  (h i))
)
(define (sumdivaux t0 n i)
  ;toto
  (let ([b (lambda (_) 
             '())])
  (if (> i n)
  1
  (let ([c (lambda (_) 
             (b 'nil))])
  (if (eq? (vector-ref t0 i) 0)
  (sumdivaux t0 n (sumdivaux2 t0 n (+ i 1)))
  (let ([o (sumdivaux t0 n (sumdivaux2 t0 n (+ i 1)))])
  (let ([out0 0])
  (let ([p i])
  (let ([f 1])
  (let ([g (vector-ref t0 i)])
  (letrec ([e (lambda (j out0 p) 
                (if (<= j g)
                (let ([out0 (+ out0 p)])
                (let ([p (* p i)])
                (e (+ j 1) out0 p)))
                (* (+ out0 1) o)))])
  (e f out0 p)))))))))))
)
(define (sumdiv nprimes primes n)
  ;toto
  (let ([t0 (array_init_withenv (+ n 1) (lambda (i) 
                                          (lambda (_) (let ([a 0])
                                                      (list '() a)))) '())])
  (let ([max0 (fillPrimesFactors t0 n primes nprimes)])
  (sumdivaux t0 max0 0)))
)
(define main
  (let ([maximumprimes 1001])
  (let ([era (array_init_withenv maximumprimes (lambda (j) 
                                                 (lambda (_) (let ([y j])
                                                             (list '() y)))) '())])
  (let ([nprimes (eratostene era maximumprimes)])
  (let ([primes (array_init_withenv nprimes (lambda (o) 
                                              (lambda (_) (let ([z 0])
                                                          (list '() z)))) '())])
  (let ([l 0])
  (let ([be 2])
  (let ([bf (- maximumprimes 1)])
  (letrec ([bd (lambda (k l) 
                 (if (<= k bf)
                 (let ([l (if (eq? (vector-ref era k) k)
                          (block
                            (vector-set! primes l k)
                            (let ([l (+ l 1)])
                            l)
                            )
                          l)])
                 (bd (+ k 1) l))
                 (block
                   (map display (list l " == " nprimes "\n"))
                   (let ([sum 0])
                   (let ([bb 2])
                   (let ([bc 1000])
                   (letrec ([ba (lambda (n sum) 
                                  (if (<= n bc)
                                  (let ([other (- (sumdiv nprimes primes n) n)])
                                  (let ([sum (if (> other n)
                                             (let ([othersum (- (sumdiv nprimes primes other) other)])
                                             (let ([sum (if (eq? othersum n)
                                                        (block
                                                          (map display (list other " & " n "\n"))
                                                          (let ([sum (+ sum (+ other n))])
                                                          sum)
                                                          )
                                                        sum)])
                                             sum))
                                             sum)])
                                  (ba (+ n 1) sum)))
                                  (block
                                    (map display (list "\n" sum "\n"))
                                    )))])
                   (ba bb sum)))))
                 )))])
  (bd be l)))))))))
)

