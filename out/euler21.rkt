#lang racket
(require racket/block)

(define array_init_withenv (lambda (len f env)
  (build-vector len (lambda (i)
    (let ([o ((f i) env)])
      (block
        (set! env (car o))
        (cadr o)
      )
    )))))
(define last-char 0)
(define next-char (lambda () (set! last-char (read-char (current-input-port)))))
(next-char)
(define mread-char (lambda ()
  (let ([ out last-char])
    (block
      (next-char)
      out
    ))))

(define mread-int (lambda ()
  (if (eq? #\- last-char)
  (block
    (next-char) (- 0 (mread-int)))
    (letrec ([w (lambda (out)
      (if (eof-object? last-char)
        out
        (if (and last-char (>= (char->integer last-char) (char->integer #\0)) (<= (char->integer last-char) (char->integer #\9)))
          (let ([out (+ (* 10 out) (- (char->integer last-char) (char->integer #\0)))])
            (block
              (next-char)
              (w out)
          ))
        out
      )))]) (w 0)))))

(define mread-blank (lambda ()
  (if (or (eq? last-char #\NewLine) (eq? last-char #\Space) ) (block (next-char) (mread-blank)) '())
))

(define eratostene (lambda (t_ max_) 
                     (let ([n 0])
                       (let ([bc 2])
                         (let ([bd (- max_ 1)])
                           (letrec ([y (lambda (i n t_ max_) 
                                         (if (<= i bd)
                                           (let ([z (lambda (n t_ max_) 
                                                      (y (+ i 1) n t_ max_))])
                                           (if (eq? (vector-ref t_ i) i)
                                             (let ([n (+ n 1)])
                                               (let ([j (* i i)])
                                                 (letrec ([bb (lambda (j n t_ max_) 
                                                                (if (and (< j max_) (> j 0))
                                                                  (block (vector-set! t_ j 0) 
                                                                  (let ([j (+ j i)])
                                                                    (bb j n t_ max_)))
                                                                  (z n t_ max_)))])
                                                 (bb j n t_ max_))))
                                           (z n t_ max_)))
                             n))])
                       (y bc n t_ max_)))))))
(define fillPrimesFactors (lambda (t_ n primes nprimes) 
                            (let ([w 0])
                              (let ([x (- nprimes 1)])
                                (letrec ([r (lambda (i t_ n primes nprimes) 
                                              (if (<= i x)
                                                (let ([d (vector-ref primes i)])
                                                  (letrec ([v (lambda (d t_ n primes nprimes) 
                                                                (if (eq? (remainder n d) 0)
                                                                  (block (vector-set! t_ d (+ (vector-ref t_ d) 1)) 
                                                                  (let ([n (quotient n d)])
                                                                    (v d t_ n primes nprimes)))
                                                                  (let ([s 
                                                                    (lambda (d t_ n primes nprimes) 
                                                                    (r (+ i 1) t_ n primes nprimes))])
                                                                  (if (eq? n 1)
                                                                    (vector-ref primes i)
                                                                    (s d t_ n primes nprimes)))))])
                                                (v d t_ n primes nprimes)))
                                  n))])
                            (r w t_ n primes nprimes))))))
(define sumdivaux2 (lambda (t_ n i) 
                     (letrec ([q (lambda (t_ n i) 
                                   (if (and (< i n) (eq? (vector-ref t_ i) 0))
                                     (let ([i (+ i 1)])
                                       (q t_ n i))
                                     i))])
                     (q t_ n i))))
(define sumdivaux (lambda (t_ n i) 
                    (let ([c (lambda (t_ n i) 
                               '())])
                    (if (> i n)
                      1
                      (let ([e (lambda (t_ n i) 
                                 (c t_ n i))])
                      (if (eq? (vector-ref t_ i) 0)
                        (sumdivaux t_ n (sumdivaux2 t_ n (+ i 1)))
                        (let ([o (sumdivaux t_ n (sumdivaux2 t_ n (+ i 1)))])
                          (let ([out_ 0])
                            (let ([p i])
                              (let ([g 1])
                                (let ([h (vector-ref t_ i)])
                                  (letrec ([f (lambda (j p out_ o t_ n i) 
                                                (if (<= j h)
                                                  (let ([out_ (+ out_ p)])
                                                    (let ([p (* p i)])
                                                      (f (+ j 1) p out_ o t_ n i)))
                                                  (* (+ out_ 1) o)))])
                                  (f g p out_ o t_ n i)))))))))))))
(define sumdiv (lambda (nprimes primes n) 
                 (let ([a (+ n 1)])
                   (let ([t_ (array_init_withenv a (lambda (i) 
                                                     (lambda (internal_env) (apply (lambda
                                                      (a nprimes primes n) 
                                                     (let ([b 0])
                                                       (list (list a nprimes primes n) b))) internal_env))) (list a nprimes primes n))])
                   (let ([max_ (fillPrimesFactors t_ n primes nprimes)])
                     (sumdivaux t_ max_ 0))))))
(define main (let ([maximumprimes 1001])
               (let ([era (array_init_withenv maximumprimes (lambda (j) 
                                                              (lambda (maximumprimes) 
                                                                (let ([be j])
                                                                  (list maximumprimes be)))) maximumprimes)])
  (let ([nprimes (eratostene era maximumprimes)])
    (let ([primes (array_init_withenv nprimes (lambda (o) 
                                                (lambda (internal_env) (apply (lambda
                                                 (nprimes maximumprimes) 
                                                (let ([bf 0])
                                                  (list (list nprimes maximumprimes) bf))) internal_env))) (list nprimes maximumprimes))])
    (let ([l 0])
      (let ([bn 2])
        (let ([bo (- maximumprimes 1)])
          (letrec ([bl (lambda (k l nprimes maximumprimes) 
                         (if (<= k bo)
                           (let ([bm (lambda (l nprimes maximumprimes) 
                                       (bl (+ k 1) l nprimes maximumprimes))])
                           (if (eq? (vector-ref era k) k)
                             (block (vector-set! primes l k) (let ([l (+ l 1)])
                                                               (bm l nprimes maximumprimes)))
                             (bm l nprimes maximumprimes)))
                         (block
                           (display l)
                           (display " == ")
                           (display nprimes)
                           (display "\n")
                           (let ([sum 0])
                             (let ([bj 2])
                               (let ([bk 1000])
                                 (letrec ([bg (lambda (n sum l nprimes maximumprimes) 
                                                (if (<= n bk)
                                                  (let ([other (- (sumdiv nprimes primes n) n)])
                                                    (let ([bh (lambda (other sum l nprimes maximumprimes) 
                                                                (bg (+ n 1) sum l nprimes maximumprimes))])
                                                    (if (> other n)
                                                      (let ([othersum (- (sumdiv nprimes primes other) other)])
                                                        (let ([bi (lambda (othersum other sum l nprimes maximumprimes) 
                                                                    (bh other sum l nprimes maximumprimes))])
                                                        (if (eq? othersum n)
                                                          (block
                                                            (display other)
                                                            (display " & ")
                                                            (display n)
                                                            (display "\n")
                                                            (let ([sum (+ sum (+ other n))])
                                                              (bi othersum other sum l nprimes maximumprimes))
                                                            )
                                                          (bi othersum other sum l nprimes maximumprimes))))
                                                    (bh other sum l nprimes maximumprimes))))
                                   (block
                                     (display "\n")
                                     (display sum)
                                     (display "\n")
                                     )))])
                             (bg bj sum l nprimes maximumprimes)))))
          )))])
  (bl bn l nprimes maximumprimes))))))))))

