#lang racket
(require racket/block)

(define (fact n)
  (let ([prod 1])
  (letrec ([h (lambda (i prod) 
                (if (<= i n)
                (let ([prod (* prod i)])
                (h (+ i 1) prod))
                prod))])
  (h 2 prod)))
)
(define (show lim nth0)
  (let ([t0 (build-vector lim (lambda (i) 
                                i))])
  (let ([pris (build-vector lim (lambda (j) 
                                  #f))])
  (letrec ([f (lambda (k nth0) 
                (if (<= k (- lim 1))
                (let ([n (fact (- lim k))])
                (let ([nchiffre (quotient nth0 n)])
                (let ([nth0 (remainder nth0 n)])
                (letrec ([g (lambda (l nchiffre) 
                              (if (<= l (- lim 1))
                              (if (not (vector-ref pris l))
                              (block
                                (if (eq? nchiffre 0)
                                (block
                                  (display l)
                                  (vector-set! pris l #t)
                                  )
                                '())
                                (let ([nchiffre (- nchiffre 1)])
                                (g (+ l 1) nchiffre))
                                )
                              (g (+ l 1) nchiffre))
                              (f (+ k 1) nth0)))])
                (g 0 nchiffre)))))
                (letrec ([e (lambda (m) 
                              (if (<= m (- lim 1))
                              (if (not (vector-ref pris m))
                              (block
                                (display m)
                                (e (+ m 1))
                                )
                              (e (+ m 1)))
                              (display "\n")))])
                (e 0))))])
(f 1 nth0))))
)
(define main
  (block
    (show 10 999999)
    '()
    )
)

