#lang racket
(require racket/block)

(define (fact n)
  (let ([prod 1])
  (letrec ([a (lambda (i prod) 
                (if (<= i n)
                (let ([prod (* prod i)])
                (a (+ i 1) prod))
                prod))])
  (a 2 prod)))
)
(define (show lim nth0)
  (let ([t0 (build-vector lim (lambda (i) 
                                i))])
  (let ([pris (build-vector lim (lambda (j) 
                                  #f))])
  (letrec ([b (lambda (k nth0) 
                (if (<= k (- lim 1))
                (let ([n (fact (- lim k))])
                (let ([nchiffre (quotient nth0 n)])
                (let ([nth0 (remainder nth0 n)])
                (letrec ([c (lambda (l nchiffre) 
                              (if (<= l (- lim 1))
                              (if (not (vector-ref pris l))
                              (block
                                (if (eq? nchiffre 0)
                                (block
                                  (display l)
                                  (vector-set! pris l #t)
                                  )
                                '())
                                (let ([nchiffre (- nchiffre 1)])
                                (c (+ l 1) nchiffre))
                                )
                              (c (+ l 1) nchiffre))
                              (b (+ k 1) nth0)))])
                (c 0 nchiffre)))))
                (letrec ([d (lambda (m) 
                              (if (<= m (- lim 1))
                              (if (not (vector-ref pris m))
                              (block
                                (display m)
                                (d (+ m 1))
                                )
                              (d (+ m 1)))
                              (display "\n")))])
                (d 0))))])
(b 1 nth0))))
)
(define main
  (block
    (show 10 999999)
    '()
    )
)

