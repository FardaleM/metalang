
macro int random(int c)
  ml do "(Random.int ($c))"
  js do "(Math.floor(Math.random() * ($c)))"
  php do "mt_rand(0, $c - 1)"
  *  do "$c"
end

macro int sqrt_(int c)
  ml do "(int_of_float (sqrt (float_of_int ( $c))))"
  js do "Math.floor(Math.sqrt($c))"
  csharp do "(int)Math.Sqrt($c)"
  py do "math.floor(math.sqrt($c))"
  ruby do "Math.sqrt($c).to_i"
  pas do "Floor(Sqrt($c))"
  java do "(int)Math.sqrt($c)"
  clisp do "(isqrt $c)"
  go do "int(math.Sqrt(float64($c)))"
  php do "intval(sqrt($c))"
  rkt do "integer-sqrt $c"
  pl do "int(sqrt($c))"
  c do "(int)sqrt($c)"
  cpp do "(int)sqrt($c)"
  objc do "(int)sqrt($c)"
  ada do "Integer(Float'Truncation(Ada.Numerics.Elementary_Functions.Sqrt(Float($c))))"
  vb do "Int(Math.Sqrt($c))"
  hs do "floor . sqrt . fromIntegral ($c)"
  * do "sqrt($c)"
end

def inline int isqrt(int c)
  tag use_math
  return sqrt_(c)
end

macro char char_of_int(int c)
  ml do "char_of_int ($c)"
  pas do "chr($c)"
  java do "(char)($c)"
  js do "String.fromCharCode($c)"
  csharp do "(char)($c)"
  php do "chr($c)"
  go do "(byte)($c)"
  clisp do "(code-char $c)"
  cpp do "(char)($c)"
  rkt do "integer->char $c"
  pl do "chr($c)"
  c do "(char)($c)"
  cpp do "(char)($c)"
  objc do "(char)($c)"
  ada do "Character'Val($c)"
  vb do "Chr($c)"
  hs do "chr ($c)"
  *  do "$c"
end

macro int int_of_char(char c)
  ml do "int_of_char ($c)"
  py do "ord($c)"
  clisp do "(char-code $c)"
  ruby do "$c.ord"
  pas do "ord($c)"
  php do "ord($c)"
  go do "(int)($c)"
  js do "$c.charCodeAt(0)"
  rkt do "char->integer $c"
  pl do "ord($c)"
  c do "(int)($c)"
  cpp do "(int)($c)"
  objc do "(int)($c)"
  ada do "Character'Pos($c)"
  vb do "Asc($c)"
  hs do "ord ($c)"
  *  do "$c"
end

def bool is_number(char c)
	return int_of_char(c) <= int_of_char('9') &&
  int_of_char(c) >= int_of_char('0')
end

macro int native_macro_max2(int a, int b)
  ml do "(max ($a) ($b))"
  js do "Math.max($a, $b)"
  java do "Math.max($a, $b)"
  csharp do "Math.Max($a, $b)"
  vb do "Math.Max($a, $b)"
  php do "max($a, $b)"
  py do "max($a, $b)"
  pl do "max($a, $b)"
  rkt do "max $a $b"
  clisp do "(max $a $b)"
  ruby do "[$a, $b].max"
  * do "max($a, $b)"
end

def int max2_(int a, int b)
 if a > b then return a else return b end
end

def lexems macro_max2(lexems a, lexems b)
  if current_language() == LANG_Java ||
  current_language() == LANG_Js ||
  current_language() == LANG_Php ||
  current_language() == LANG_Cs ||
  current_language() == LANG_Vb ||
  current_language() == LANG_Rkt ||
  current_language() == LANG_Ml ||
  current_language() == LANG_Fun_ml ||
  current_language() == LANG_Py ||
  current_language() == LANG_Pl ||
  current_language() == LANG_Rb
  then
    return { 
    tag perl_use_list_min
    return native_macro_max2( ${a}, ${b}) }
  else
    return  { return max2_(${a}, ${b}) }
  end
end

def inline int max2(int a, int b)
	${ macro_max2( {a}, {b} ) }
end

macro int native_macro_min2(int a, int b)
  ml do "(min ($a) ($b))"
  js do "Math.min($a, $b)"
  java do "Math.min($a, $b)"
  csharp do "Math.Min($a, $b)"
  vb do  "Math.Min($a, $b)"
  php do "min($a, $b)"
  py do "min($a, $b)"
  rkt do "min $a $b"
  clisp do "(min $a $b)"
  ruby do "[$a, $b].min"
  pl do "min($a, $b)"
  * do "min($a, $b)"
end

macro int native_macro_min3(int a, int b, int c)
  js do "Math.min($a, $b, $c)"
  php do "min($a, $b, $c)"
  py do "min($a, $b, $c)"
  rkt do "min $a $b $c"
  clisp do "(min $a $b $c)"
  ruby do "[$a, $b, $c].min"
  pl do "min($a, $b, $c)"
  * do "min($a, $b, $c)"
end

macro int native_macro_min4(int a, int b, int c, int d)
  js do "Math.min($a, $b, $c, $d)"
  php do "min($a, $b, $c, $d)"
  py do "min($a, $b, $c, $d)"
  rkt do "min $a $b $c $d"
  clisp do "(min $a $b $c $d)"
  ruby do "[$a, $b, $c, $d].min"
  pl do "min($a, $b, $c, $d)"
  * do "min($a, $b, $c, $d)"
end

def int min2_(int a, int b)
  if a < b then return a else return b end 
end

def lexems macro_min2(lexems a, lexems b)
  if current_language() == LANG_Java ||
  current_language() == LANG_Js ||
  current_language() == LANG_Php ||
  current_language() == LANG_Cs ||
  current_language() == LANG_Vb ||
  current_language() == LANG_Ml ||
  current_language() == LANG_Fun_ml ||
  current_language() == LANG_Py ||
  current_language() == LANG_Rkt ||
  current_language() == LANG_Cl ||
  current_language() == LANG_Rb ||
  current_language() == LANG_Vb ||
  current_language() == LANG_Pl
  then
    return { 
    tag perl_use_list_min
    return native_macro_min2( ${a}, ${b}) }
  else
    return  { return min2_(${a}, ${b})}
  end
end

def inline int min2(int a, int b)
	${ macro_min2( {a}, {b} ) }
end

def lexems macro_min3(lexems a, lexems b, lexems c)
  if current_language() == LANG_Js ||
  current_language() == LANG_Php ||
  current_language() == LANG_Py ||
  current_language() == LANG_Rkt ||
  current_language() == LANG_Cl ||
  current_language() == LANG_Rb ||
  current_language() == LANG_Pl ||
  current_language() == LANG_Pl
  then
    return { tag perl_use_list_min return native_macro_min3( ${a}, ${b}, ${c}) }
  else
    return { return min2(min2( ${a}, ${b}), ${c}) }
  end
end

def inline int min3(int a, int b, int c)
	${ macro_min3( {a}, {b}, {c} )}
end

def lexems macro_min4(lexems a, lexems b, lexems c, lexems d)
  if current_language() == LANG_Js ||
  current_language() == LANG_Php ||
  current_language() == LANG_Py  ||
  current_language() == LANG_Rkt ||
  current_language() == LANG_Cl ||
  current_language() == LANG_Rb ||
  current_language() == LANG_Pl
  then
    return { tag perl_use_list_min return native_macro_min4( ${a}, ${b}, ${c}, ${d}) }
  else
    return { 	return min3(min2(a, b), c, d) }
  end
end

def inline int min4(int a, int b, int c, int d)
	${ macro_min4( {a}, {b}, {c}, {d} )}
end

def int pgcd(int a, int b)
	def c = min2(a, b)
	def d = max2(a, b)
	def reste = d % c
	if reste == 0 then
		return c
	else
		return pgcd(c, reste)
	end
end

macro array<int> native_expand_read_int_line()
  py do "list(map(int, input().split()))"
  php do "array_map(\"intval\", explode(\" \", fgets(STDIN)))"
  csharp do "new List<string>(Console.ReadLine().Split(\" \".ToCharArray())).ConvertAll(int.Parse).ToArray()"
  vb do "Array(Of String).ConvertAll(Of String, Integer)(Console.ReadLine().Split(\" \".ToCharArray()), New Converter(Of String, Integer)(AddressOf Integer.Parse))"
  rkt do "list->vector (map string->number (regexp-split \" \" (read-line)))"
  ruby do "STDIN.readline.split(\" \").map{ |x| x.to_i(10) }"
  pl do "[ map { int($_) } split(/\\s+/, <STDIN>) ]"
  java do "read_int_line()"
  *  do "E R R O R"
end

macro array<char> native_expand_read_char_line()
  py do "list(input())"
  php do "fgets(STDIN)"
  csharp do "Console.ReadLine().ToCharArray()"
  vb do "Console.ReadLine().ToCharArray()"
  cpp do "getline()"
  rkt do "list->vector (string->list (read-line))"
  ruby do "STDIN.readline.split(//)"
  pl do "[split(//, <STDIN>)]"
  java do "scanner.nextLine().toCharArray()"
  *  do "E R R O R"
end

macro array<array<int>> py_expand_read_int_matrix(int y)
  py do "[list(map(int, input().split())) for i in range($y)]"
  ruby do "[*1..$y].map { |l| STDIN.readline.split(\" \").map{ |x| x.to_i(10) } }"
  *  do "E R R O R"
end

macro int native_expand_read_int()
  py do "int(input())"
  php do "intval(trim(fgets(STDIN)))"
  csharp do "int.Parse(Console.ReadLine())"
  vb do "Integer.Parse(Console.ReadLine())"
  ml do "Scanf.scanf \"%d \" (fun x -> x)"
  rkt do "string->number (read-line)"
  ruby do "STDIN.readline.to_i(10)"
  pl do "int( <STDIN> )"
  java do "Integer.parseInt(scanner.nextLine())"
  *  do "E R R O R"
end

def lexems expand_read_int()
if current_language() == LANG_Ml ||
current_language() == LANG_Fun_ml
then
  return {
  return native_expand_read_int()
  }
	elsif current_language() == LANG_Py ||
	current_language() == LANG_Php ||
	current_language() == LANG_Rkt ||
	current_language() == LANG_Pl ||
	current_language() == LANG_Cs ||
	current_language() == LANG_Vb ||
	current_language() == LANG_Java ||
	current_language() == LANG_Rb
	then
    return {
    tag use_readline
		tag use_readmacros
    return native_expand_read_int()
    }
  else
    return { def inline read int out skip; return out }
	end
end

def inline int read_int()
  ${ expand_read_int() }
end

def lexems expand_read_int_line(lexems a)
    if current_language() == LANG_Py ||
	current_language() == LANG_Php ||
	current_language() == LANG_Cs ||
	current_language() == LANG_Vb ||
	current_language() == LANG_Pl ||
	current_language() == LANG_Rkt ||
	current_language() == LANG_Java ||
	current_language() == LANG_Rb
	  then
      return {
        tag use_java_readline
        tag use_readmacros
        tag use_readline
        return native_expand_read_int_line()
      }
    else
    return {
      def inline array<int> tab[${a}] with i do
      	def inline read int t skip
				return t
      end
      return tab
    }
   end
end

def inline array<int> read_int_line(int n)
  ${expand_read_int_line( {n} )}
end

def lexems expand_read_char_line(lexems a)
  if current_language() == LANG_Cc
  then
    return {
      tag use_cc_readline
    return native_expand_read_char_line( )
    }
  elsif current_language() == LANG_Py ||
	current_language() == LANG_Php ||
	current_language() == LANG_Rkt ||
	current_language() == LANG_Pl ||
	current_language() == LANG_Cs ||
	current_language() == LANG_Vb ||
	current_language() == LANG_Java ||
	current_language() == LANG_Rb
	  then
      return {
      tag use_readline
			tag use_readmacros
      return native_expand_read_char_line()
      }
    else
    return {
      def inline array<char> tab[${a}] with i do
      	def inline read char t;
				return t;
      end
			skip
      return tab
    }
   end
end

def inline array<char> read_char_line(int n)
    ${expand_read_char_line( {n} )}
end

def lexems expand_read_int_matrix(lexems x, lexems y)
    if current_language() == LANG_Py ||
       current_language() == LANG_Rb then
      return {
        return py_expand_read_int_matrix( ${ y } )
      }
    else
			def s = {skip}
			if current_language() == LANG_Php ||
			current_language() == LANG_Cs ||
			current_language() == LANG_Java ||
			current_language() == LANG_Vb
			then
				s = {}
			end
    return {
      def inline array<array<int>> tab[${y}] with z do
				return read_int_line(x)
      end
      return tab
    }
   end
end

def inline array<array<int>> read_int_matrix(int x, int y)
    ${expand_read_int_matrix( {x}, {y} )}
end

def lexems expand_read_char_matrix(lexems x, lexems y)
	return {
  def array<array<char>> tab[${y}] with z do
		return read_char_line(x)
  end
  return tab
  }
end

def inline array<array<char>> read_char_matrix(int x, int y)
    ${expand_read_char_matrix( {x}, {y} )}
end



macro (int, int) native_expand_read_int_couple()
  py do "list(map(int, input().split()))"
  php do "array_map(\"intval\", explode(\" \", fgets(STDIN)))"
  ruby do "STDIN.readline.split(\" \").map{ |x| x.to_i(10) }"
  pl do "[ map { int($_) } split(/\\s+/, <STDIN>) ]"
  rkt do "map string->number (regexp-split \" \" (read-line))"
  *  do "E R R O R"
end

def lexems expand_read_int_couple()
  if current_language() == LANG_Vb || current_language() == LANG_Cs || current_language() == LANG_Java then
    return { def array<int> l = read_int_line(2)
    return (l[0], l[1]) }
  elsif current_language() == LANG_Py ||
    current_language() == LANG_Php ||
    current_language() == LANG_Rb ||
    current_language() == LANG_Rkt ||
    current_language() == LANG_Pl
  then
    return { return native_expand_read_int_couple() }
  else
    return {
    def inline read int a skip
    def inline read int b skip
    return (a, b)
    }
  end
end

def inline (int, int) read_int_couple()
  ${ expand_read_int_couple() }
end



macro (int, int, int) native_expand_read_3ints()
  py do "list(map(int, input().split()))"
  php do "array_map(\"intval\", explode(\" \", fgets(STDIN)))"
  ruby do "STDIN.readline.split(\" \").map{ |x| x.to_i(10) }"
  pl do "[ map { int($_) } split(/\\s+/, <STDIN>) ]"
  rkt do "map string->number (regexp-split \" \" (read-line))"
  *  do "E R R O R"
end

def lexems expand_read_3ints()
  if current_language() == LANG_Vb || current_language() == LANG_Cs || current_language() == LANG_Java then
    return { def array<int> l = read_int_line(3)
    return (l[0], l[1], l[2]) }
  elsif current_language() == LANG_Py ||
    current_language() == LANG_Php ||
    current_language() == LANG_Rb ||
    current_language() == LANG_Rkt ||
    current_language() == LANG_Pl
  then
    return { return native_expand_read_3ints() }
  else
    return {
    def inline read int a skip
    def inline read int b skip
    def inline read int c skip
    return (a, b, c)
    }
  end
end

def inline (int, int, int) read_3ints()
  ${ expand_read_3ints() }
end
